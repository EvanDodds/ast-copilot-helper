/**
 * Vulnerability Detection Engine
 * 
 * Comprehensive vulnerability scanning system with:
 * - Pattern-based vulnerability detection
 * - CVE database integration  
 * - Severity classification
 * - Custom vulnerability patterns
 * - Dependency vulnerability scanning
 * - Security hotspot identification
 * 
 * Acceptance Criteria: AC13-AC18
 */

import type { SecuritySeverity, VulnerabilityReport, VulnerabilityFinding, SecurityConfig } from './types.js';
import { AstLogger } from '../logging/logger.js';
import { LogLevel } from '../logging/types.js';

/**
 * Vulnerability pattern interface for extensible detection
 */
export interface VulnerabilityPattern {
  id: string;
  name: string;
  description: string;
  severity: SecuritySeverity;
  pattern: RegExp;
  cveIds?: string[];
  category: 'injection' | 'xss' | 'cryptographic' | 'authentication' | 'authorization' | 'configuration' | 'dependency' | 'other';
  owasp?: string[]; // OWASP Top 10 categories
  cwe?: string[];   // CWE identifiers
}

/**
 * CVE (Common Vulnerabilities and Exposures) entry
 */
export interface CVEEntry {
  id: string;
  description: string;
  severity: SecuritySeverity;
  cvssScore: number;
  publishedDate: string;
  lastModifiedDate: string;
  references: string[];
  cwe?: string[];
  affectedVersions?: string[];
}

/**
 * Dependency vulnerability information
 */
export interface DependencyVulnerability {
  packageName: string;
  currentVersion: string;
  vulnerableVersions: string[];
  fixedVersion?: string;
  cve: CVEEntry;
  severity: SecuritySeverity;
  exploitabilityScore: number;
  impactScore: number;
}

/**
 * Security hotspot for prioritized attention
 */
export interface SecurityHotspot {
  id: string;
  title: string;
  description: string;
  severity: SecuritySeverity;
  confidence: 'high' | 'medium' | 'low';
  location: {
    file: string;
    line: number;
    column?: number;
    snippet?: string;
  };
  category: string;
  remediation: string;
  references: string[];
}

/**
 * Comprehensive vulnerability scanner implementation
 */
export class VulnerabilityScanner {
  private logger: AstLogger;
  private config: SecurityConfig;
  private vulnerabilityPatterns: Map<string, VulnerabilityPattern> = new Map();
  private cveDatabase: Map<string, CVEEntry> = new Map();
  private dependencyCache: Map<string, DependencyVulnerability[]> = new Map();

  constructor(config: SecurityConfig) {
    this.config = config;
    this.logger = new AstLogger({ 
      level: LogLevel.INFO,
      operation: 'vulnerability-scanner' 
    });
    this.initializeDefaultPatterns();
  }

  /**
   * Perform comprehensive vulnerability scan
   */
  async scanForVulnerabilities(content: string, filePath?: string): Promise<VulnerabilityReport> {
    const startTime = Date.now();
    const findings: VulnerabilityFinding[] = [];
    const hotspots: SecurityHotspot[] = [];

    try {
      this.logger.info('Starting vulnerability scan', { filePath, contentLength: content.length });

      // Pattern-based vulnerability detection
      const patternFindings = await this.scanWithPatterns(content, filePath);
      findings.push(...patternFindings);

      // Security hotspot identification
      const identifiedHotspots = await this.identifySecurityHotspots(content, filePath);
      hotspots.push(...identifiedHotspots);

      // Dependency vulnerability scanning (if package.json or similar)
      if (this.isDependencyFile(filePath)) {
        const dependencyFindings = await this.scanDependencyVulnerabilities(content, filePath);
        findings.push(...dependencyFindings);
      }

      // Generate comprehensive report
      const report: VulnerabilityReport = {
        timestamp: new Date().toISOString(),
        scanDuration: Date.now() - startTime,
        totalFindings: findings.length,
        findingsBySeverity: this.categorizeBySeverity(findings),
        findings,
        hotspots,
        summary: {
          criticalCount: findings.filter(f => f.severity === 'critical').length,
          highCount: findings.filter(f => f.severity === 'high').length,
          mediumCount: findings.filter(f => f.severity === 'medium').length,
          lowCount: findings.filter(f => f.severity === 'low').length,
          hotspotsCount: hotspots.length,
          riskScore: this.calculateRiskScore(findings, hotspots)
        },
        metadata: {
          scannerVersion: '1.0.0',
          patternsUsed: Array.from(this.vulnerabilityPatterns.keys()),
          configLevel: this.config.auditLevel
        }
      };

      this.logger.info('Vulnerability scan completed', {
        totalFindings: findings.length,
        criticalFindings: report.summary.criticalCount,
        riskScore: report.summary.riskScore
      });

      return report;

    } catch (error) {
      this.logger.error('Vulnerability scan failed', { error: error instanceof Error ? error.message : String(error), filePath });
      throw new Error(`Vulnerability scan failed: ${error instanceof Error ? error.message : String(error)}`);
    }
  }

  /**
   * Scan for dependency vulnerabilities
   */
  async scanDependencyVulnerabilities(content: string, filePath?: string): Promise<VulnerabilityFinding[]> {
    const findings: VulnerabilityFinding[] = [];

    try {
      // Parse dependency information
      const dependencies = await this.parseDependencies(content, filePath);
      
      this.logger.info('Scanning dependencies for vulnerabilities', { 
        dependencyCount: dependencies.length,
        filePath 
      });

      for (const dep of dependencies) {
        // Check cache first
        const cacheKey = `${dep.name}@${dep.version}`;
        if (this.dependencyCache.has(cacheKey)) {
          const cachedVulns = this.dependencyCache.get(cacheKey)!;
          findings.push(...this.convertDependencyVulnsToFindings(cachedVulns, dep, filePath));
          continue;
        }

        // Scan for known vulnerabilities
        const vulnerabilities = await this.checkDependencyVulnerabilities(dep);
        this.dependencyCache.set(cacheKey, vulnerabilities);

        // Convert to findings
        findings.push(...this.convertDependencyVulnsToFindings(vulnerabilities, dep, filePath));
      }

      return findings;

    } catch (error) {
      this.logger.warn('Dependency vulnerability scan failed', { error: error instanceof Error ? error.message : String(error), filePath });
      return [];
    }
  }

  /**
   * Identify security hotspots for prioritized attention
   */
  async identifySecurityHotspots(content: string, filePath?: string): Promise<SecurityHotspot[]> {
    const hotspots: SecurityHotspot[] = [];
    const lines = content.split('\n');

    // High-priority patterns that indicate security hotspots
    const hotspotPatterns = [
      {
        pattern: /(password|secret|key|token|credential)\s*[=:]\s*['"][^'"]+['"]/gi,
        title: 'Hardcoded Credentials',
        description: 'Potential hardcoded credentials detected',
        severity: 'critical' as SecuritySeverity,
        confidence: 'high' as const,
        category: 'authentication',
        remediation: 'Move credentials to environment variables or secure configuration files'
      },
      {
        pattern: /(eval|exec|system|shell_exec|passthru)\s*\(/gi,
        title: 'Code Execution Function',
        description: 'Dangerous code execution function detected',
        severity: 'high' as SecuritySeverity,
        confidence: 'high' as const,
        category: 'injection',
        remediation: 'Avoid dynamic code execution, use safe alternatives'
      },
      {
        pattern: /\$\{[^}]*\}/g,
        title: 'Template Injection Risk',
        description: 'Template injection vulnerability possible',
        severity: 'medium' as SecuritySeverity,
        confidence: 'medium' as const,
        category: 'injection',
        remediation: 'Validate and sanitize template inputs'
      },
      {
        pattern: /(md5|sha1)\s*\(/gi,
        title: 'Weak Cryptographic Hash',
        description: 'Weak cryptographic hash function detected',
        severity: 'medium' as SecuritySeverity,
        confidence: 'high' as const,
        category: 'cryptographic',
        remediation: 'Use stronger hash functions like SHA-256 or SHA-3'
      }
    ];

    for (const hotspotDef of hotspotPatterns) {
      let match;
      while ((match = hotspotDef.pattern.exec(content)) !== null) {
        const lineNum = content.slice(0, match.index).split('\n').length;
        const line = lines[lineNum - 1] || '';
        
        const hotspot: SecurityHotspot = {
          id: `hotspot-${hotspots.length + 1}`,
          title: hotspotDef.title,
          description: hotspotDef.description,
          severity: hotspotDef.severity,
          confidence: hotspotDef.confidence,
          location: {
            file: filePath || 'unknown',
            line: lineNum,
            column: match.index - content.lastIndexOf('\n', match.index - 1),
            snippet: line.trim()
          },
          category: hotspotDef.category,
          remediation: hotspotDef.remediation,
          references: []
        };

        hotspots.push(hotspot);
        
        // Reset regex to avoid infinite loops
        if (!hotspotDef.pattern.global) {
break;
}
      }
      
      // Reset global regex
      hotspotDef.pattern.lastIndex = 0;
    }

    return hotspots;
  }

  /**
   * Add custom vulnerability pattern
   */
  addVulnerabilityPattern(pattern: VulnerabilityPattern): void {
    this.vulnerabilityPatterns.set(pattern.id, pattern);
    this.logger.info('Added custom vulnerability pattern', { patternId: pattern.id, category: pattern.category });
  }

  /**
   * Remove vulnerability pattern
   */
  removeVulnerabilityPattern(patternId: string): boolean {
    const removed = this.vulnerabilityPatterns.delete(patternId);
    if (removed) {
      this.logger.info('Removed vulnerability pattern', { patternId });
    }
    return removed;
  }

  /**
   * Update CVE database entries
   */
  updateCVEDatabase(entries: CVEEntry[]): void {
    for (const entry of entries) {
      this.cveDatabase.set(entry.id, entry);
    }
    this.logger.info('Updated CVE database', { entriesCount: entries.length });
  }

  /**
   * Get vulnerability statistics
   */
  getVulnerabilityStatistics(): {
    totalPatterns: number;
    cveEntries: number;
    cacheSize: number;
    patternsByCategory: Record<string, number>;
  } {
    const patternsByCategory: Record<string, number> = {};
    for (const pattern of this.vulnerabilityPatterns.values()) {
      patternsByCategory[pattern.category] = (patternsByCategory[pattern.category] || 0) + 1;
    }

    return {
      totalPatterns: this.vulnerabilityPatterns.size,
      cveEntries: this.cveDatabase.size,
      cacheSize: this.dependencyCache.size,
      patternsByCategory
    };
  }

  /**
   * Private: Pattern-based vulnerability scanning
   */
  private async scanWithPatterns(content: string, filePath?: string): Promise<VulnerabilityFinding[]> {
    const findings: VulnerabilityFinding[] = [];

    for (const [patternId, pattern] of this.vulnerabilityPatterns) {
      try {
        const matches = this.findPatternMatches(content, pattern);
        
        for (const match of matches) {
          const finding: VulnerabilityFinding = {
            id: `${patternId}-${findings.length}`,
            title: pattern.name,
            description: pattern.description,
            severity: pattern.severity,
            category: pattern.category,
            location: {
              file: filePath || 'unknown',
              line: match.line,
              column: match.column,
              snippet: match.snippet
            },
            cveIds: pattern.cveIds || [],
            owaspCategories: pattern.owasp || [],
            cweIds: pattern.cwe || [],
            remediation: this.getRemediationGuidance(pattern),
            references: this.getReferences(pattern),
            confidence: 'medium',
            firstDetected: new Date().toISOString()
          };

          findings.push(finding);
        }

      } catch (error) {
        this.logger.warn('Pattern matching failed', { 
          patternId, 
          error: error instanceof Error ? error.message : String(error) 
        });
      }
    }

    return findings;
  }

  /**
   * Private: Find pattern matches in content
   */
  private findPatternMatches(content: string, pattern: VulnerabilityPattern): Array<{
    line: number;
    column: number;
    snippet: string;
    match: string;
  }> {
    const matches: Array<{
      line: number;
      column: number;
      snippet: string;
      match: string;
    }> = [];

    const lines = content.split('\n');
    
    for (let lineIndex = 0; lineIndex < lines.length; lineIndex++) {
      const line = lines[lineIndex];
      if (!line) {
continue;
} // Skip empty/undefined lines
      
      const regex = new RegExp(pattern.pattern);
      let match;

      while ((match = regex.exec(line)) !== null) {
        matches.push({
          line: lineIndex + 1,
          column: match.index + 1,
          snippet: line.trim(),
          match: match[0]
        });

        if (!regex.global) {
break;
}
      }
    }

    return matches;
  }

  /**
   * Private: Initialize default vulnerability patterns
   */
  private initializeDefaultPatterns(): void {
    const defaultPatterns: VulnerabilityPattern[] = [
      {
        id: 'sql-injection-basic',
        name: 'Basic SQL Injection',
        description: 'Potential SQL injection vulnerability',
        severity: 'high',
        category: 'injection',
        pattern: /(SELECT|INSERT|UPDATE|DELETE|DROP|UNION).*(["'].*\+.*["']|["'].*\+|query.*\+)/i,
        owasp: ['A03:2021-Injection'],
        cwe: ['CWE-89']
      },
      {
        id: 'xss-script-tag',
        name: 'XSS Script Tag',
        description: 'Potential XSS vulnerability via script tag',
        severity: 'high',
        category: 'xss',
        pattern: /<script[^>]*>.*<\/script>|innerHTML\s*(\+=|=.*\+)/i,
        owasp: ['A03:2021-Injection'],
        cwe: ['CWE-79']
      },
      {
        id: 'weak-crypto-md5',
        name: 'Weak Cryptography (MD5)',
        description: 'MD5 hash function is cryptographically weak',
        severity: 'medium',
        category: 'cryptographic',
        pattern: /\bmd5\s*\(/i,
        cwe: ['CWE-327']
      },
      {
        id: 'hardcoded-secrets',
        name: 'Hardcoded Secrets',
        description: 'Potential hardcoded secrets or credentials',
        severity: 'critical',
        category: 'authentication',
        pattern: /(password|secret|key|token|api_key)\s*[=:]\s*['"][a-zA-Z0-9]{8,}['"]/i,
        owasp: ['A07:2021-Identification and Authentication Failures'],
        cwe: ['CWE-798']
      },
      {
        id: 'command-injection',
        name: 'Command Injection',
        description: 'Potential command injection vulnerability',
        severity: 'high',
        category: 'injection',
        pattern: /\b(exec|execSync|spawn|system|eval|shell_exec|passthru|popen)\s*\(/i,
        owasp: ['A03:2021-Injection'],
        cwe: ['CWE-78']
      }
    ];

    for (const pattern of defaultPatterns) {
      this.vulnerabilityPatterns.set(pattern.id, pattern);
    }

    this.logger.info('Initialized default vulnerability patterns', { count: defaultPatterns.length });
  }

  /**
   * Private: Check if file is a dependency file
   */
  private isDependencyFile(filePath?: string): boolean {
    if (!filePath) {
return false;
}
    
    const dependencyFiles = [
      'package.json',
      'package-lock.json',
      'yarn.lock',
      'Pipfile',
      'requirements.txt',
      'composer.json',
      'pom.xml',
      'Gemfile'
    ];

    return dependencyFiles.some(dep => filePath.endsWith(dep));
  }

  /**
   * Private: Parse dependencies from content
   */
  private async parseDependencies(content: string, filePath?: string): Promise<Array<{
    name: string;
    version: string;
    type: 'dependency' | 'devDependency' | 'peerDependency';
  }>> {
    const dependencies: Array<{
      name: string;
      version: string;
      type: 'dependency' | 'devDependency' | 'peerDependency';
    }> = [];

    try {
      if (filePath?.endsWith('package.json')) {
        const packageData = JSON.parse(content);
        
        // Regular dependencies
        if (packageData.dependencies) {
          for (const [name, version] of Object.entries(packageData.dependencies)) {
            dependencies.push({ name, version: version as string, type: 'dependency' });
          }
        }

        // Dev dependencies
        if (packageData.devDependencies) {
          for (const [name, version] of Object.entries(packageData.devDependencies)) {
            dependencies.push({ name, version: version as string, type: 'devDependency' });
          }
        }

        // Peer dependencies
        if (packageData.peerDependencies) {
          for (const [name, version] of Object.entries(packageData.peerDependencies)) {
            dependencies.push({ name, version: version as string, type: 'peerDependency' });
          }
        }
      }

      // TODO: Add parsers for other dependency file types
    } catch (error) {
      this.logger.warn('Failed to parse dependencies', { 
        error: error instanceof Error ? error.message : String(error), 
        filePath 
      });
    }

    return dependencies;
  }

  /**
   * Private: Check dependency for known vulnerabilities
   */
  private async checkDependencyVulnerabilities(dependency: {
    name: string;
    version: string;
    type: string;
  }): Promise<DependencyVulnerability[]> {
    // This would integrate with actual vulnerability databases
    // For now, return mock data based on known patterns
    const mockVulnerabilities: DependencyVulnerability[] = [];

    // Check against known vulnerable packages
    const knownVulnerable = [
      { name: 'lodash', versions: ['4.0.0', '4.1.0'], cve: 'CVE-2019-10744' },
      { name: 'axios', versions: ['0.18.0'], cve: 'CVE-2020-28168' }
    ];

    for (const vuln of knownVulnerable) {
      if (dependency.name === vuln.name && vuln.versions.includes(dependency.version)) {
        const cveEntry: CVEEntry = {
          id: vuln.cve,
          description: `Known vulnerability in ${vuln.name}`,
          severity: 'high',
          cvssScore: 7.5,
          publishedDate: '2023-01-01T00:00:00Z',
          lastModifiedDate: '2023-01-01T00:00:00Z',
          references: [`https://cve.mitre.org/cgi-bin/cvename.cgi?name=${vuln.cve}`]
        };

        mockVulnerabilities.push({
          packageName: dependency.name,
          currentVersion: dependency.version,
          vulnerableVersions: vuln.versions,
          cve: cveEntry,
          severity: 'high',
          exploitabilityScore: 8.0,
          impactScore: 7.0
        });
      }
    }

    return mockVulnerabilities;
  }

  /**
   * Private: Convert dependency vulnerabilities to findings
   */
  private convertDependencyVulnsToFindings(
    vulns: DependencyVulnerability[], 
    dependency: { name: string; version: string; type: string }, 
    filePath?: string
  ): VulnerabilityFinding[] {
    return vulns.map((vuln, index) => ({
      id: `dep-${dependency.name}-${index}`,
      title: `Vulnerable Dependency: ${vuln.packageName}`,
      description: `${vuln.packageName}@${vuln.currentVersion} has known vulnerability ${vuln.cve.id}`,
      severity: vuln.severity,
      category: 'dependency' as const,
      location: {
        file: filePath || 'package.json',
        line: 1,
        column: 1,
        snippet: `"${vuln.packageName}": "${vuln.currentVersion}"`
      },
      cveIds: [vuln.cve.id],
      owaspCategories: ['A06:2021-Vulnerable and Outdated Components'],
      cweIds: ['CWE-1104'],
      remediation: vuln.fixedVersion ? 
        `Upgrade to version ${vuln.fixedVersion} or later` : 
        'Update to a secure version',
      references: vuln.cve.references,
      confidence: 'high',
      firstDetected: new Date().toISOString()
    }));
  }

  /**
   * Private: Categorize findings by severity
   */
  private categorizeBySeverity(findings: VulnerabilityFinding[]): Record<SecuritySeverity, VulnerabilityFinding[]> {
    const categorized: Record<SecuritySeverity, VulnerabilityFinding[]> = {
      critical: [],
      high: [],
      medium: [],
      low: []
    };

    for (const finding of findings) {
      const severity = finding.severity as SecuritySeverity;
      if (categorized[severity]) {
        categorized[severity].push(finding);
      }
    }

    return categorized;
  }

  /**
   * Private: Calculate overall risk score
   */
  private calculateRiskScore(findings: VulnerabilityFinding[], hotspots: SecurityHotspot[]): number {
    let score = 0;
    
    // Weight findings by severity
    for (const finding of findings) {
      switch (finding.severity) {
        case 'critical': score += 10; break;
        case 'high': score += 7; break;
        case 'medium': score += 4; break;
        case 'low': score += 1; break;
      }
    }

    // Add hotspot weights
    for (const hotspot of hotspots) {
      const confidenceMultiplier = hotspot.confidence === 'high' ? 1.0 : 
                                  hotspot.confidence === 'medium' ? 0.7 : 0.4;
      switch (hotspot.severity) {
        case 'critical': score += 8 * confidenceMultiplier; break;
        case 'high': score += 5 * confidenceMultiplier; break;
        case 'medium': score += 3 * confidenceMultiplier; break;
        case 'low': score += 1 * confidenceMultiplier; break;
      }
    }

    // Normalize to 0-100 scale
    return Math.min(100, Math.round(score));
  }

  /**
   * Private: Get remediation guidance for pattern
   */
  private getRemediationGuidance(pattern: VulnerabilityPattern): string {
    const remediationMap: Record<string, string> = {
      'injection': 'Use parameterized queries and input validation',
      'xss': 'Sanitize user input and encode output',
      'cryptographic': 'Use strong, up-to-date cryptographic algorithms',
      'authentication': 'Implement proper authentication and avoid hardcoded credentials',
      'authorization': 'Implement proper access controls and permission checks',
      'configuration': 'Review and secure configuration settings',
      'dependency': 'Update vulnerable dependencies to secure versions'
    };

    return remediationMap[pattern.category] || 'Review code and apply security best practices';
  }

  /**
   * Private: Get references for pattern
   */
  private getReferences(pattern: VulnerabilityPattern): string[] {
    const references: string[] = [];

    if (pattern.owasp && pattern.owasp.length > 0) {
      references.push('https://owasp.org/Top10/');
    }

    if (pattern.cwe && pattern.cwe.length > 0) {
      for (const cwe of pattern.cwe) {
        references.push(`https://cwe.mitre.org/data/definitions/${cwe.replace('CWE-', '')}.html`);
      }
    }

    return references;
  }
}