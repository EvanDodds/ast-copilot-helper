name: Release Pipeline

on:
  release:
    types: [published]
  workflow_dispatch:
    inputs:
      version:
        description: "Release version (e.g., v1.0.0)"
        required: true
        type: string
      channels:
        description: "Distribution channels"
        required: false
        default: "all"
        type: choice
        options:
          - all
          - npm-only
          - binaries-only
          - github-only
          - docker-only
      dry_run:
        description: "Perform dry run (validation only)"
        required: false
        default: false
        type: boolean

permissions:
  contents: write
  packages: write
  actions: read
  id-token: write

# Cancel previous runs when new commits are pushed
concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

env:
  NODE_VERSION: "24"
  REGISTRY_URL: "https://registry.npmjs.org"

jobs:
  # ===============================
  # VALIDATION AND PREPARATION
  # ===============================
  
  validate:
    name: Pre-Release Validation
    runs-on: ubuntu-latest
    outputs:
      should-continue: ${{ steps.validation.outputs.should-continue }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'yarn'

      - name: Install dependencies
        run: |
          echo "ðŸ“¦ Installing dependencies..."
          yarn install --frozen-lockfile

      - name: Run basic validation
        id: validation
        run: |
          echo "ðŸ” Running basic validation..."
          
          # Type checking
          echo "ðŸ”§ Type checking..."
          yarn typecheck || exit 1
          
          # Run essential tests
          echo "ðŸ§ª Running essential tests..."
          yarn test:unit || exit 1
          
          # Build validation
          echo "ðŸ—ï¸ Build validation..."
          yarn build || exit 1
          
          echo "should-continue=true" >> $GITHUB_OUTPUT
          echo "âœ… Basic validation passed"

  prepare:
    name: Prepare Release
    runs-on: ubuntu-latest
    needs: validate
    if: needs.validate.outputs.should-continue == 'true'
    outputs:
      version: ${{ steps.version.outputs.version }}
      version-no-v: ${{ steps.version.outputs.version-no-v }}
      channels: ${{ steps.channels.outputs.channels }}
      should-publish: ${{ steps.check.outputs.should-publish }}
      is-prerelease: ${{ steps.version.outputs.is-prerelease }}
      is-dry-run: ${{ steps.check.outputs.is-dry-run }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Determine version
        id: version
        run: |
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            VERSION="${{ github.event.inputs.version }}"
            if [[ ! "$VERSION" =~ ^v?[0-9]+\.[0-9]+\.[0-9]+(-.*)?$ ]]; then
              echo "âŒ Invalid version format: $VERSION"
              exit 1
            fi
            # Ensure version starts with 'v'
            if [[ ! "$VERSION" =~ ^v ]]; then
              VERSION="v$VERSION"
            fi
          elif [ "${{ github.event_name }}" = "release" ]; then
            VERSION="${{ github.event.release.tag_name }}"
          else
            echo "âŒ Unexpected event: ${{ github.event_name }}"
            exit 1
          fi
          
          VERSION_NO_V="${VERSION#v}"
          
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "version-no-v=$VERSION_NO_V" >> $GITHUB_OUTPUT
          echo "ðŸ“‹ Release version: $VERSION (npm: $VERSION_NO_V)"
          
          # Check if prerelease
          if [[ "$VERSION" =~ -[a-zA-Z] ]]; then
            echo "is-prerelease=true" >> $GITHUB_OUTPUT
            echo "ðŸš§ This is a pre-release version"
          else
            echo "is-prerelease=false" >> $GITHUB_OUTPUT
          fi

      - name: Determine distribution channels
        id: channels
        run: |
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            CHANNELS="${{ github.event.inputs.channels }}"
          else
            CHANNELS="all"
          fi
          
          echo "channels=$CHANNELS" >> $GITHUB_OUTPUT
          echo "ðŸ“¢ Distribution channels: $CHANNELS"

      - name: Check publish readiness
        id: check
        run: |
          echo "ðŸ” Checking publish readiness..."
          
          # Check if this is a dry run
          if [ "${{ github.event_name }}" = "workflow_dispatch" ] && [ "${{ github.event.inputs.dry_run }}" = "true" ]; then
            echo "is-dry-run=true" >> $GITHUB_OUTPUT
            echo "should-publish=false" >> $GITHUB_OUTPUT
            echo "ï¿½ Dry run mode - no actual publishing"
            exit 0
          fi
          
          echo "is-dry-run=false" >> $GITHUB_OUTPUT
          echo "should-publish=true" >> $GITHUB_OUTPUT
          echo "âœ… Ready for publishing"

  # ===============================
  # BUILD CROSS-PLATFORM BINARIES
  # ===============================

  build-binaries:
    name: Build Binaries (${{ matrix.platform }})
    runs-on: ${{ matrix.os }}
    needs: [prepare]
    if: |
      needs.prepare.outputs.is-dry-run == 'false' && 
      (needs.prepare.outputs.channels == 'all' || needs.prepare.outputs.channels == 'binaries-only')
    
    strategy:
      fail-fast: false
      matrix:
        include:
          - os: ubuntu-latest
            platform: linux
            target: linux-x64
          - os: macos-latest
            platform: darwin
            target: darwin-x64
          - os: windows-latest
            platform: win32
            target: win32-x64

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'yarn'
          
      - name: Verify Node.js SEA support
        shell: bash
        run: |
          echo "ðŸ” Verifying Node.js SEA support..."
          echo "Node.js version: $(node --version)"
          echo "Platform: ${{ runner.os }}"
          
          # Check if SEA is supported
          if node --help | grep -q "experimental-sea-config"; then
            echo "âœ… Node.js supports Single Executable Applications (SEA)"
          else
            echo "âŒ Node.js does not support SEA in this version"
            echo "SEA support requires Node.js 20.12.0 or later"
            echo "Current version: $(node --version)"
            exit 1
          fi

      - name: Setup Rust (for WASM)
        uses: dtolnay/rust-toolchain@stable
        with:
          toolchain: stable

      - name: Install dependencies
        run: |
          echo "ðŸ“¦ Installing dependencies..."
          yarn install --frozen-lockfile
          
      - name: Install Windows-specific build tools (Windows only)
        if: matrix.platform == 'win32'
        shell: pwsh
        run: |
          Write-Host "ðŸ”§ Installing Windows-specific build tools..."
          Write-Host "Node.js version: $(node --version)"
          Write-Host "NPM version: $(npm --version)"
          Write-Host "Platform: ${{ runner.os }}"
          
          # Check if Node.js supports SEA
          Write-Host "ðŸ” Checking Node.js SEA support..."
          try {
            node --help | Select-String "experimental-sea" -ErrorAction Stop
            Write-Host "âœ… Node.js supports SEA"
          } catch {
            Write-Host "âŒ Node.js does not appear to support SEA"
            Write-Host "Available experimental features:"
            node --help | Select-String "experimental"
          }
          
          # Ensure postject is available
          Write-Host "Installing postject globally..."
          npm install -g postject@latest
          if ($LASTEXITCODE -ne 0) {
            Write-Host "âŒ Failed to install postject"
            exit 1
          }
          Write-Host "âœ… Postject installed successfully"
          
          # Verify postject is available
          Write-Host "Verifying postject installation..."
          try {
            $postjectPath = Get-Command postject -ErrorAction Stop
            Write-Host "âœ… Postject found at: $($postjectPath.Source)"
          } catch {
            Write-Host "âŒ Postject not found in PATH"
            Write-Host "PATH: $env:PATH"
            try {
              Get-Command npm -ErrorAction Stop | Select-Object Source
              $npmGlobalPath = npm root -g
              Write-Host "NPM global path: $npmGlobalPath"
              Get-ChildItem "$npmGlobalPath\.bin" -ErrorAction SilentlyContinue | Where-Object Name -like "*postject*"
            } catch {
              Write-Host "Could not check npm global path"
            }
            exit 1
          }
          
          # Test postject functionality
          try {
            $null = npx postject --help 2>$null
            Write-Host "âœ… Postject is working"
          } catch {
            Write-Host "âš ï¸ Postject help command failed, but binary exists"
          }
          
      - name: Test binary build environment (Windows only)
        if: matrix.platform == 'win32'
        shell: pwsh
        run: |
          Write-Host "ðŸ§ª Testing binary build environment..."
          Write-Host "Running comprehensive build environment test..."
          
          try {
            npx tsx "scripts/build/test-binary-build.ts"
            Write-Host "âœ… Build environment test passed"
          } catch {
            Write-Host "âŒ Build environment test failed: $_"
            Write-Host "This indicates an issue with the binary build environment"
            
            # Run individual tests for more detailed diagnosis
            Write-Host "ðŸ” Running individual diagnostics..."
            
            Write-Host "Node.js SEA support:"
            try {
              node --help | Select-String "experimental-sea"
              Write-Host "âœ… SEA support found"
            } catch {
              Write-Host "âŒ SEA support not found"
            }
            
            Write-Host "Postject availability:"
            try {
              npx postject --help | Out-Null
              Write-Host "âœ… Postject is available"
            } catch {
              Write-Host "âŒ Postject not available"
            }
            
            throw "Build environment test failed"
          }

      - name: Build project
        run: |
          echo "ðŸ—ï¸ Building project..."
          yarn build

      - name: Build binary for Windows
        if: matrix.platform == 'win32'
        shell: pwsh
        run: |
          Write-Host "ðŸ”¨ Building binary for ${{ matrix.platform }}"
          Write-Host "Platform: ${{ matrix.platform }}"
          Write-Host "Target: ${{ matrix.target }}"
          Write-Host "OS: ${{ runner.os }}"
          Write-Host "Node.js executable: $(Get-Command node | Select-Object -ExpandProperty Source)"
          Write-Host "Working directory: $(Get-Location)"
          Write-Host "Environment PATH: $env:PATH"
          
          # Ensure the CLI module is built
          if (-not (Test-Path "packages/ast-helper/dist/cli.js")) {
            Write-Host "âŒ CLI module not found, rebuilding..."
            yarn build
            if ($LASTEXITCODE -ne 0) {
              Write-Host "âŒ Project build failed"
              exit 1
            }
          }
          
          Write-Host "âœ… CLI module exists: packages/ast-helper/dist/cli.js"
          Write-Host "âœ… CLI module size: $((Get-Item 'packages/ast-helper/dist/cli.js').Length) bytes"
          
          # Verify required build tools are available
          Write-Host "ðŸ” Verifying build environment..."
          Write-Host "NCC available: $(if (Get-Command npx -ErrorAction SilentlyContinue) { 'Yes' } else { 'No' })"
          Write-Host "Postject available: $(if (Get-Command postject -ErrorAction SilentlyContinue) { 'Yes' } else { 'No' })"
          
          # Build the binary with verbose output
          Write-Host "ðŸ”¨ Starting binary build process..."
          $env:DEBUG = "1"
          yarn build:binary:${{ matrix.platform }}
          
          if ($LASTEXITCODE -ne 0) {
            Write-Host "âŒ Primary binary build failed with exit code $LASTEXITCODE"
            Write-Host "ðŸ“‹ Current directory contents:"
            Get-ChildItem | Format-Table
            Write-Host "ðŸ“‹ Dist directory contents (if exists):"
            if (Test-Path "dist") {
              Get-ChildItem -Recurse "dist" | Select-Object FullName, Length | Format-Table
            } else {
              Write-Host "dist directory not found"
            }
            
            Write-Host "ðŸ”„ Attempting fallback build with direct npx call..."
            try {
              npx tsx "./scripts/build/build-binaries.ts" --platform win32
              if ($LASTEXITCODE -eq 0) {
                Write-Host "âœ… Fallback build succeeded"
              } else {
                Write-Host "âŒ Fallback build also failed"
                exit 1
              }
            } catch {
              Write-Host "âŒ Fallback build threw exception: $_"
              exit 1
            }
          }

      - name: Build binary for Unix
        if: matrix.platform != 'win32'
        shell: bash
        run: |
          echo "ðŸ”¨ Building binary for ${{ matrix.platform }}"
          echo "Platform: ${{ matrix.platform }}"
          echo "Target: ${{ matrix.target }}"
          echo "OS: ${{ runner.os }}"
          echo "Node.js executable: $(which node)"
          echo "Working directory: $(pwd)"
          
          # Ensure the CLI module is built
          if [ ! -f "packages/ast-helper/dist/cli.js" ]; then
            echo "âŒ CLI module not found, rebuilding..."
            yarn build
          fi
          
          # Build the binary with verbose output
          set -e  # Exit on any error
          yarn build:binary:${{ matrix.platform }} || {
            echo "âŒ Binary build failed with exit code $?"
            echo "ðŸ“‹ Current directory contents:"
            ls -la
            echo "ðŸ“‹ Dist directory contents (if exists):"
            [ -d "dist" ] && find dist -type f || echo "dist directory not found"
            exit 1
          }

      - name: Debug Windows binary build results
        if: matrix.platform == 'win32'
        shell: pwsh
        run: |
          Write-Host "ðŸ” Debugging binary build results for ${{ matrix.platform }}"
          Write-Host "Working directory: $(Get-Location)"
          Write-Host "Node.js version: $(node --version)"
          Write-Host "NPM version: $(npm --version)"
          Write-Host "Yarn version: $(yarn --version)"
          Write-Host ""
          Write-Host "ðŸ“‚ Contents of dist directory:"
          if (Test-Path "dist") {
            Get-ChildItem -Recurse "dist" -File | Select-Object -First 20 | Select-Object FullName, Length | Format-Table
          } else {
            Write-Host "dist directory does not exist"
          }
          Write-Host ""
          Write-Host "ðŸ“‚ Contents of dist/binaries directory:"
          if (Test-Path "dist/binaries") {
            Get-ChildItem "dist/binaries" | Format-Table Name, Length, LastWriteTime
          } else {
            Write-Host "dist/binaries directory does not exist"
          }
          Write-Host ""
          Write-Host "ðŸ” Searching for any files containing 'ast-copilot-helper':"
          try {
            Get-ChildItem -Recurse -File -Name "*ast-copilot-helper*" | Select-Object -First 10
          } catch {
            Write-Host "No files found or search failed"
          }

      - name: Debug Unix binary build results
        if: matrix.platform != 'win32'
        shell: bash
        run: |
          echo "ðŸ” Debugging binary build results for ${{ matrix.platform }}"
          echo "Working directory: $(pwd)"
          echo "Node.js version: $(node --version)"
          echo "NPM version: $(npm --version)"
          echo "Yarn version: $(yarn --version)"
          echo ""
          echo "ðŸ“‚ Contents of dist directory:"
          if [ -d "dist" ]; then
            find dist -type f -name "*" | head -20
          else
            echo "dist directory does not exist"
          fi
          echo ""
          echo "ðŸ“‚ Contents of dist/binaries directory:"
          if [ -d "dist/binaries" ]; then
            ls -la dist/binaries/
          else
            echo "dist/binaries directory does not exist"
          fi
          echo ""
          echo "ðŸ” Searching for any files containing 'ast-copilot-helper':"
          find . -name "*ast-copilot-helper*" -type f 2>/dev/null | head -10 || echo "No files found"

      - name: Verify and prepare Windows binary
        if: matrix.platform == 'win32'
        shell: pwsh
        run: |
          Write-Host "ðŸ” Verifying binary for ${{ matrix.platform }}"
          
          # Create binaries directory if it doesn't exist
          if (-not (Test-Path "dist/binaries")) {
            New-Item -ItemType Directory -Force -Path "dist/binaries"
          }
          
          # Expected binary paths based on platform
          $EXPECTED_BINARY = "dist/binaries/ast-copilot-helper-${{ matrix.target }}.exe"
          
          # Check if binary exists
          if (Test-Path $EXPECTED_BINARY) {
            Write-Host "âœ… Binary found at: $EXPECTED_BINARY"
            Get-ChildItem $EXPECTED_BINARY | Format-List
            
            # Get file size
            $SIZE = (Get-Item $EXPECTED_BINARY).Length
            Write-Host "ðŸ“Š Binary size: $SIZE bytes ($([math]::Round($SIZE/1MB, 2)) MB)"
            
            # Test if the binary is executable
            Write-Host "ðŸ§ª Testing binary execution..."
            try {
              & $EXPECTED_BINARY --version
              Write-Host "âœ… Binary is executable"
            } catch {
              Write-Host "âš ï¸ Binary test failed: $_"
            }
          } else {
            Write-Host "âŒ Binary not found at expected location: $EXPECTED_BINARY"
            Write-Host "ðŸ“‹ Directory contents:"
            if (Test-Path "dist") {
              Get-ChildItem -Recurse "dist" -File -Name "*ast-copilot-helper*" -ErrorAction SilentlyContinue
            }
            
            Write-Host "ðŸ“‹ All files in dist/binaries (if exists):"
            if (Test-Path "dist/binaries") {
              Get-ChildItem "dist/binaries" | Format-Table
            } else {
              Write-Host "dist/binaries directory does not exist"
            }
            
            Write-Host "ðŸ“‹ Searching entire workspace for binaries:"
            Get-ChildItem -Recurse -File -Name "*.exe" -ErrorAction SilentlyContinue | Select-Object -First 10
            
            exit 1
          }

      - name: Verify and prepare Unix binary
        if: matrix.platform != 'win32'
        shell: bash
        run: |
          echo "ðŸ” Verifying binary for ${{ matrix.platform }}"
          
          # Create binaries directory if it doesn't exist
          mkdir -p dist/binaries
          
          # Expected binary paths based on platform
          EXPECTED_BINARY="dist/binaries/ast-copilot-helper-${{ matrix.target }}"
          
          # Check if binary exists
          if [ -f "$EXPECTED_BINARY" ]; then
            echo "âœ… Binary found at: $EXPECTED_BINARY"
            ls -la "$EXPECTED_BINARY"
            
            # Make executable on non-Windows
            chmod +x "$EXPECTED_BINARY"
            
            # Get file size
            SIZE=$(stat -c%s "$EXPECTED_BINARY" 2>/dev/null || stat -f%z "$EXPECTED_BINARY" 2>/dev/null || echo "unknown")
            echo "ðŸ“Š Binary size: $SIZE bytes"
            
            # Test if the binary is executable
            echo "ðŸ§ª Testing binary execution..."
            "$EXPECTED_BINARY" --version || echo "âš ï¸ Binary test failed"
          else
            echo "âŒ Binary not found at expected location: $EXPECTED_BINARY"
            echo "ðŸ“‹ Directory contents:"
            find dist -name "*ast-copilot-helper*" -type f 2>/dev/null || echo "No binaries found in dist"
            echo "ðŸ“‹ Searching workspace for binaries:"
            find . -name "ast-copilot-helper*" -type f 2>/dev/null | head -10 || echo "No binaries found in workspace"
            exit 1
          fi

      - name: Upload binary artifact
        uses: actions/upload-artifact@v4
        with:
          name: binary-${{ matrix.target }}
          path: |
            dist/binaries/*
          retention-days: 30

  # ===============================
  # NPM PUBLISHING
  # ===============================

  publish-npm:
    name: Publish to npm
    runs-on: ubuntu-latest
    needs: [prepare]
    if: |
      needs.prepare.outputs.should-publish == 'true' && 
      (needs.prepare.outputs.channels == 'all' || needs.prepare.outputs.channels == 'npm-only')
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'yarn'
          registry-url: ${{ env.REGISTRY_URL }}

      - name: Install dependencies
        run: |
          echo "ðŸ“¦ Installing dependencies..."
          yarn install --frozen-lockfile

      - name: Build for publishing
        run: |
          echo "ðŸ—ï¸ Building for publishing..."
          yarn build

      - name: Update package version
        run: |
          echo "ðŸ“ Updating package.json version..."
          VERSION_NO_V="${{ needs.prepare.outputs.version-no-v }}"
          echo "Setting version to: $VERSION_NO_V"
          npm version "$VERSION_NO_V" --no-git-tag-version --allow-same-version

      - name: Publish to npm
        env:
          NODE_AUTH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "ðŸ“¤ Publishing to npm..."
          VERSION_NO_V="${{ needs.prepare.outputs.version-no-v }}"
          
          # Check if we have npm token configured
          if [ -z "$NODE_AUTH_TOKEN" ]; then
            echo "âš ï¸ No NPM token configured, skipping npm publish"
            exit 0
          fi
          
          # Publish based on prerelease status
          if [ "${{ needs.prepare.outputs.is-prerelease }}" = "true" ]; then
            echo "ðŸš§ Publishing pre-release to npm..."
            npm publish --tag beta --access public || echo "âŒ npm publish failed"
          else
            echo "ðŸš€ Publishing stable release to npm..."
            npm publish --access public || echo "âŒ npm publish failed"
          fi
          
          echo "âœ… npm publish completed for version $VERSION_NO_V"

  # ===============================
  # GITHUB RELEASE
  # ===============================

  create-github-release:
    name: Create GitHub Release
    runs-on: ubuntu-latest
    needs: [prepare, build-binaries]
    if: |
      always() && !failure() && !cancelled() &&
      needs.prepare.outputs.is-dry-run == 'false' && 
      (needs.prepare.outputs.channels == 'all' || needs.prepare.outputs.channels == 'github-only')
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Download all binary artifacts
        uses: actions/download-artifact@v4
        with:
          path: ./artifacts
          pattern: binary-*
          merge-multiple: true

      - name: Prepare release assets
        run: |
          echo "ðŸ“¦ Preparing release assets..."
          mkdir -p release-assets
          
          # Copy binaries and create checksums
          find artifacts -name "ast-copilot-helper-*" -type f | while read binary; do
            if [ -f "$binary" ]; then
              echo "ðŸ“„ Adding: $binary"
              cp "$binary" release-assets/
              # Create checksum
              basename_binary=$(basename "$binary")
              if command -v sha256sum >/dev/null; then
                sha256sum "$binary" | sed "s|$binary|$basename_binary|" >> release-assets/checksums.txt
              elif command -v shasum >/dev/null; then
                shasum -a 256 "$binary" | sed "s|$binary|$basename_binary|" >> release-assets/checksums.txt
              fi
            fi
          done
          
          # List assets
          echo "ðŸ“‹ Release assets:"
          ls -la release-assets/

      - name: Generate release body
        id: release-body
        run: |
          VERSION="${{ needs.prepare.outputs.version }}"
          echo "Generating release notes for $VERSION"
          
          cat > release-body.txt << EOF
          ## ðŸš€ Release $VERSION
          
          ### Installation
          
          **Via npm:**
          \`\`\`bash
          npm install -g ast-copilot-helper@${{ needs.prepare.outputs.version-no-v }}
          \`\`\`
          
          **Via binary download:**
          Download the appropriate binary for your platform from the assets below.
          
          ### Available Binaries
          - **Windows**: \`ast-copilot-helper-win32-x64.exe\`
          - **macOS**: \`ast-copilot-helper-darwin-x64\`
          - **Linux**: \`ast-copilot-helper-linux-x64\`
          
          See \`checksums.txt\` for file verification.
          
          ---
          
          **Full Changelog**: https://github.com/EvanDodds/ast-copilot-helper/compare/v1.4.0...$VERSION
          EOF

      - name: Create/Update GitHub Release
        uses: ncipollo/release-action@v1
        with:
          tag: ${{ needs.prepare.outputs.version }}
          name: "Release ${{ needs.prepare.outputs.version }}"
          bodyFile: "release-body.txt"
          artifacts: "release-assets/*"
          token: ${{ secrets.GITHUB_TOKEN }}
          draft: false
          prerelease: ${{ needs.prepare.outputs.is-prerelease }}
          allowUpdates: true
          replacesArtifacts: true
          generateReleaseNotes: false

  # ===============================
  # DOCKER IMAGES
  # ===============================

  build-docker:
    name: Build Docker Images
    runs-on: ubuntu-latest
    needs: [prepare]
    if: |
      needs.prepare.outputs.is-dry-run == 'false' && 
      (needs.prepare.outputs.channels == 'all' || needs.prepare.outputs.channels == 'docker-only')
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ghcr.io/${{ github.repository }}
          tags: |
            type=raw,value=${{ needs.prepare.outputs.version }}
            type=raw,value=latest,enable=true

      - name: Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          platforms: linux/amd64
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Test Docker image
        run: |
          echo "ðŸ§ª Testing Docker image..."
          VERSION="${{ needs.prepare.outputs.version }}"
          timeout 30s docker run --rm ghcr.io/${{ github.repository }}:$VERSION --help || echo "Docker test completed"

  # ===============================
  # POST-RELEASE SUMMARY
  # ===============================

  summary:
    name: Release Summary
    runs-on: ubuntu-latest
    needs: [prepare, publish-npm, create-github-release, build-docker]
    if: always() && !cancelled()
    
    steps:
      - name: Release summary
        run: |
          echo "ðŸŽ‰ Release Pipeline Summary"
          echo "=========================="
          echo "Version: ${{ needs.prepare.outputs.version }}"
          echo "Channels: ${{ needs.prepare.outputs.channels }}"
          echo "Dry Run: ${{ needs.prepare.outputs.is-dry-run }}"
          echo ""
          
          # Individual job results
          echo "ðŸ“‹ Job Results:"
          echo "â€¢ NPM Publish: ${{ needs.publish-npm.result || 'skipped' }}"
          echo "â€¢ GitHub Release: ${{ needs.create-github-release.result || 'skipped' }}"
          echo "â€¢ Docker Build: ${{ needs.build-docker.result || 'skipped' }}"
          echo ""
          
          # Overall status
          if [ "${{ needs.prepare.outputs.is-dry-run }}" = "true" ]; then
            echo "ðŸ” Dry run completed - no publishing performed"
          else
            echo "ðŸš€ Release pipeline completed"
          fi