#!/usr/bin/env node

const fs = require('fs');
const path = require('path');

/**
 * Generate NAPI binding files for development and CI environments
 * This creates index.js and index.d.ts files that match our Rust NAPI exports
 * when the full NAPI build process isn't available.
 */

const engineDir = path.resolve(__dirname, '..', 'packages', 'ast-core-engine');
const indexJsPath = path.join(engineDir, 'index.js');
const indexDtsPath = path.join(engineDir, 'index.d.ts');

console.log('üîß Generating NAPI binding files...');

// Generate index.js - cross-platform native module loader
const indexJsContent = `/* tslint:disable */
/* eslint-disable */

/* auto-generated by NAPI-RS */

const { existsSync, readFileSync } = require('fs')
const { join } = require('path')

const { platform, arch } = process

let nativeBinding = null
let localFileExisted = false
let loadError = null

function isMusl() {
  // For Node 10 and below, we can try to detect musl by looking at the ldd command
  if (process.platform !== 'linux') {
    return false
  }
  
  // Try to detect musl by checking if we can run ldd and if it mentions musl
  try {
    const { execSync } = require('child_process')
    const lddOutput = execSync('ldd --version 2>&1 || true', { encoding: 'utf8' })
    return lddOutput.includes('musl')
  } catch {
    // Fallback: check if /etc/alpine-release exists (Alpine Linux uses musl)
    try {
      return existsSync('/etc/alpine-release')
    } catch {
      return false
    }
  }
}

// Since we're using a custom binding approach with local .node files,
// we skip platform-specific package resolution and go directly to local files

// Try to find a local .node file
const localNodeFiles = [
  \`ast-core-engine.\${platform}-\${arch}\${isMusl() ? '-musl' : arch === 'x64' && platform === 'linux' ? '-gnu' : ''}.node\`,
  'ast-core-engine.linux-x64-gnu.node',
  'ast-core-engine.node'
]

for (const nodeFile of localNodeFiles) {
  const localPath = join(__dirname, nodeFile)
  if (existsSync(localPath)) {
    try {
      nativeBinding = require(localPath)
      localFileExisted = true
      console.log(\`Loaded local native binding: \${nodeFile}\`)
      break
    } catch (error) {
      console.warn(\`Failed to load \${nodeFile}:\`, error.message)
    }
  }
}

if (!nativeBinding) {
  // For CI/development environments where .node files don't exist yet,
  // we create a stub that will fail gracefully at runtime but allow TypeScript compilation
  console.warn('‚ö†Ô∏è  No native binding found - creating runtime stub for TypeScript compilation')
  console.warn('   This is normal in CI environments. The module will fail at runtime until Rust binaries are built.')
  console.warn(\`   Platform: \${platform}, Architecture: \${arch}\`)
  if (platform === 'linux') {
    console.warn(\`   Musl detected: \${isMusl()}\`)
  }
  console.warn('   To build native binaries: cargo build --release')
  
  // Create a stub that provides the correct interface but throws at runtime
  nativeBinding = {
    AstCoreEngineApi: class AstCoreEngineApi {
      constructor() { throw new Error('Native binding not available - run cargo build --release') }
      initialize() { throw new Error('Native binding not available - run cargo build --release') }
      processBatch() { throw new Error('Native binding not available - run cargo build --release') }
      searchSimilar() { throw new Error('Native binding not available - run cargo build --release') }
    },
    createDefaultEngine: () => { throw new Error('Native binding not available - run cargo build --release') }
  }
}

// Export all the native functions and classes
const {
  AstCoreEngineApi,
  createDefaultEngine
} = nativeBinding

module.exports = {
  AstCoreEngineApi,
  createDefaultEngine
}
`;

// Generate index.d.ts - TypeScript definitions
const indexDtsContent = `/* tslint:disable */
/* eslint-disable */

/* auto-generated by NAPI-RS */

/** Configuration for batch processing */
export interface EngineConfig {
  maxMemoryMb: number;
  batchSize: number;
  parallelWorkers: number;
  vectorDimensions: number;
  indexEfConstruction: number;
  indexM: number;
  maxDepth: number;
  includeUnnamedNodes: boolean;
  maxNodeLength: number;
  enableCaching: boolean;
}

/** HNSW index configuration */
export interface HnswConfig {
  vectorDimensions: number;
  indexEfConstruction: number;
  indexM: number;
}

/** Processing error information */
export interface ProcessingError {
  filePath: string;
  message: string;
  errorType: string;
  line?: number;
  column?: number;
}

/** Node metadata for AST nodes */
export interface NodeMetadata {
  language: string;
  scope: string[];
  modifiers: string[];
  imports: string[];
  exports: string[];
  docstring?: string;
  annotations: string[];
  languageSpecific?: Record<string, any>;
  // Additional properties used by semantic processor
  nodeId: string;
  filePath: string;
  signature?: string;
  summary?: string;
  sourceSnippet?: string;
  complexity?: number;
}

/** Batch processing result */
export interface BatchResult {
  processedFiles: number;
  totalNodes: number;
  processingTimeMs: number;
  memoryPeakMb: number;
  errors: ProcessingError[];
}

/** Main AST Core Engine API class */
export declare class AstCoreEngineApi {
  /** Create a new engine instance with the given configuration */
  constructor(config: EngineConfig);
  
  /** Initialize the engine */
  initialize(): Promise<void>;
  
  /** Process a batch of files */
  processBatch(filePaths: string[], config: EngineConfig): Promise<BatchResult>;
  
  /** Search for similar nodes using semantic search */
  searchSimilar(queryText: string, maxResults?: number): Promise<NodeMetadata[]>;
}

/** Create a default engine instance */
export declare function createDefaultEngine(): Promise<AstCoreEngineApi>;
`;

// Write the files
try {
  console.log(`  ‚Üí Writing ${indexJsPath}`);
  fs.writeFileSync(indexJsPath, indexJsContent, 'utf8');
  
  console.log(`  ‚Üí Writing ${indexDtsPath}`);
  fs.writeFileSync(indexDtsPath, indexDtsContent, 'utf8');
  
  console.log('‚úÖ Successfully generated NAPI binding files');
  console.log('   These files provide TypeScript support and cross-platform loading');
  console.log('   for the Rust NAPI engine in development and CI environments.');
  
} catch (error) {
  console.error('‚ùå Failed to generate binding files:', error.message);
  process.exit(1);
}