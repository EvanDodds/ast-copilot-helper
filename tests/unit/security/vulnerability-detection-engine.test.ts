/**
 * Vulnerability Scanner Test Suite
 * 
 * Tests for comprehensive vulnerability detection system including:
 * - Pattern-based vulnerability detection
 * - CVE database integration
 * - Severity classification
 * - Custom vulnerability patterns
 * - Dependency vulnerability scanning
 * - Security hotspot identification
 * 
 * Acceptance Criteria: AC13-AC18
 */

import { describe, it, expect, beforeEach } from 'vitest';
import { VulnerabilityScanner } from '../../../packages/ast-helper/src/security/vulnerability-scanner.js';
import { SecurityConfig, SecuritySeverity, VulnerabilityFinding } from '../../../packages/ast-helper/src/security/types.js';

describe('Vulnerability Detection Engine', () => {
  let scanner: VulnerabilityScanner;
  let config: SecurityConfig;

  beforeEach(async () => {
    config = {
      auditLevel: 'comprehensive',
      maxAuditTime: 60000,
      dependencyScanning: true,
      includeThirdParty: true,
      penetrationTesting: false,
      complianceFrameworks: ['OWASP', 'CWE', 'NIST'],
      codeAnalysis: true,
      configurationAudit: true,
      customRules: [],

      audit: {
        level: 'comprehensive',
        maxAuditTime: 60000,
        enableDependencyScanning: true,
        complianceFrameworks: ['OWASP', 'CWE', 'NIST']
      },

      vulnerability: {
        enabled: true,
        reportSeverities: ['low', 'medium', 'high', 'critical'],
        customPatterns: []
      },

      hardening: {
        enabled: true,
        rules: []
      },

      compliance: {
        enabled: true,
        reportFormat: 'json',
        includeRemediation: true
      }
    };

    scanner = new VulnerabilityScanner(config);
  });

  describe('Core Vulnerability Scanner', () => {
    describe('Initialization', () => {
      it('should initialize successfully with default configuration', async () => {
        expect(scanner).toBeDefined();
        
        const stats = scanner.getVulnerabilityStatistics();
        expect(stats.totalPatterns).toBeGreaterThan(0);
        expect(stats.patternsByCategory).toBeDefined();
      });

      it('should initialize with custom configuration', async () => {
        const customConfig = {
          ...config,
          auditLevel: 'basic' as const,
          vulnerability: {
            ...config.vulnerability,
            reportSeverities: ['high', 'critical'] as SecuritySeverity[]
          }
        };

        const customScanner = new VulnerabilityScanner(customConfig);
        expect(customScanner).toBeDefined();
      });
    });

    describe('Pattern-based Vulnerability Detection - AC14', () => {
      it('should detect SQL injection patterns', async () => {
        const sqlInjectionCode = `
          const query = "SELECT * FROM users WHERE id = '" + userId + "'";
          db.execute("DELETE FROM accounts WHERE 1=1 OR " + userInput);
          const badQuery = 'SELECT * FROM passwords WHERE user="' + req.body.user + '"';
        `;

        const report = await scanner.scanForVulnerabilities(sqlInjectionCode, 'test-sql.js');
        
        expect(report.totalFindings).toBeGreaterThan(0);
        expect(report.findings.some(f => f.category === 'injection')).toBe(true);
        expect(report.summary.criticalCount + report.summary.highCount).toBeGreaterThan(0);
      });

      it('should detect XSS vulnerabilities', async () => {
        const xssCode = `
          document.getElementById('content').innerHTML = '<script>alert("XSS")</script>';
          element.outerHTML = "<img src='x' onerror='alert(1)'>";
          const dangerous = "<iframe src='javascript:alert(1)'></iframe>";
        `;

        const report = await scanner.scanForVulnerabilities(xssCode, 'test-xss.js');
        
        expect(report.totalFindings).toBeGreaterThan(0);
        expect(report.findings.some(f => f.category === 'xss')).toBe(true);
      });

      it('should detect command injection patterns', async () => {
        const commandInjectionCode = `
          exec("ls -la " + userInput);
          system("rm -rf " + req.params.file);
          eval("console.log('" + dangerous + "')");
        `;

        const report = await scanner.scanForVulnerabilities(commandInjectionCode, 'test-cmd.js');
        
        expect(report.totalFindings).toBeGreaterThan(0);
        expect(report.findings.some(f => f.category === 'injection')).toBe(true);
      });

      it('should detect hardcoded credentials', async () => {
        const credentialCode = `
          const apiKey = "sk-1234567890abcdef";
          const password = "mySecretPassword123";
          const token = "bearer_token_abc123def456";
        `;

        const report = await scanner.scanForVulnerabilities(credentialCode, 'test-creds.js');
        
        expect(report.totalFindings).toBeGreaterThan(0);
        expect(report.findings.some(f => f.category === 'authentication')).toBe(true);
        expect(report.summary.criticalCount).toBeGreaterThan(0);
      });

      it('should detect weak cryptography', async () => {
        const weakCryptoCode = `
          const hash = md5(password);
          const digest = crypto.createHash('sha1').update(data).digest('hex');
        `;

        const report = await scanner.scanForVulnerabilities(weakCryptoCode, 'test-crypto.js');
        
        expect(report.totalFindings).toBeGreaterThan(0);
        expect(report.findings.some(f => f.category === 'cryptographic')).toBe(true);
      });

      it('should allow safe code without false positives', async () => {
        const safeCode = `
          const safeQuery = db.prepare("SELECT * FROM users WHERE id = ?").bind(userId);
          const encodedOutput = escapeHtml(userInput);
          const strongHash = crypto.createHash('sha256').update(data).digest('hex');
          const configKey = process.env.API_KEY;
        `;

        const report = await scanner.scanForVulnerabilities(safeCode, 'test-safe.js');
        
        // Should have very few or no findings for safe code
        expect(report.totalFindings).toBeLessThan(2);
      });
    });

    describe('Severity Classification System - AC15', () => {
      it('should classify vulnerabilities by severity levels', async () => {
        const mixedCode = `
          const critical = "password = 'hardcoded123'";
          const high = "exec(userInput)";
          const medium = "md5(data)";
        `;

        const report = await scanner.scanForVulnerabilities(mixedCode, 'test-severity.js');
        
        expect(report.findingsBySeverity).toBeDefined();
        expect(report.findingsBySeverity.critical).toBeDefined();
        expect(report.findingsBySeverity.high).toBeDefined();
        expect(report.findingsBySeverity.medium).toBeDefined();
        expect(report.findingsBySeverity.low).toBeDefined();

        expect(report.summary.criticalCount).toBeGreaterThan(0);
        expect(report.summary.riskScore).toBeGreaterThan(0);
      });

      it('should calculate risk scores accurately', async () => {
        const highRiskCode = `
          const secret = "api_secret_key_123";
          exec("rm -rf " + userPath);
          document.innerHTML = userContent;
        `;

        const lowRiskCode = `
          console.log('Safe logging');
          const hash = crypto.createHash('sha256');
        `;

        const highRiskReport = await scanner.scanForVulnerabilities(highRiskCode, 'high-risk.js');
        const lowRiskReport = await scanner.scanForVulnerabilities(lowRiskCode, 'low-risk.js');

        expect(highRiskReport.summary.riskScore).toBeGreaterThan(lowRiskReport.summary.riskScore);
      });
    });

    describe('Custom Vulnerability Patterns - AC16', () => {
      it('should allow adding custom vulnerability patterns', async () => {
        const customPattern = {
          id: 'custom-pattern-test',
          name: 'Custom Test Pattern',
          description: 'Test pattern for custom vulnerabilities',
          severity: 'medium' as SecuritySeverity,
          category: 'other' as const,
          pattern: /customBadFunction\s*\(/i,
          cwe: ['CWE-999']
        };

        scanner.addVulnerabilityPattern(customPattern);

        const testCode = `
          customBadFunction(userInput);
          normalFunction();
        `;

        const report = await scanner.scanForVulnerabilities(testCode, 'test-custom.js');
        
        expect(report.findings.some(f => f.id.includes('custom-pattern-test'))).toBe(true);
      });

      it('should allow removing vulnerability patterns', async () => {
        const customPattern = {
          id: 'removable-pattern',
          name: 'Removable Pattern',
          description: 'Pattern that can be removed',
          severity: 'low' as SecuritySeverity,
          category: 'other' as const,
          pattern: /removableFunction\s*\(/i
        };

        scanner.addVulnerabilityPattern(customPattern);
        const removed = scanner.removeVulnerabilityPattern('removable-pattern');
        
        expect(removed).toBe(true);

        const testCode = 'removableFunction(test);';
        const report = await scanner.scanForVulnerabilities(testCode, 'test-removed.js');
        
        expect(report.findings.some(f => f.id.includes('removable-pattern'))).toBe(false);
      });

      it('should support OWASP and CWE mappings in custom patterns', async () => {
        const owaspPattern = {
          id: 'owasp-test-pattern',
          name: 'OWASP Test Pattern',
          description: 'Pattern with OWASP mapping',
          severity: 'high' as SecuritySeverity,
          category: 'injection' as const,
          pattern: /owaspTestFunction\s*\(/i,
          owasp: ['A03:2021-Injection'],
          cwe: ['CWE-89']
        };

        scanner.addVulnerabilityPattern(owaspPattern);

        const testCode = 'owaspTestFunction(userInput);';
        const report = await scanner.scanForVulnerabilities(testCode, 'test-owasp.js');
        
        const finding = report.findings.find(f => f.id.includes('owasp-test-pattern'));
        expect(finding).toBeDefined();
        expect(finding?.owaspCategories).toContain('A03:2021-Injection');
        expect(finding?.cweIds).toContain('CWE-89');
      });
    });

    describe('Dependency Vulnerability Scanning - AC17', () => {
      it('should scan package.json for dependency vulnerabilities', async () => {
        const packageJson = JSON.stringify({
          name: 'test-project',
          dependencies: {
            'lodash': '4.0.0',  // Known vulnerable version
            'axios': '0.18.0'   // Known vulnerable version
          }
        }, null, 2);

        const report = await scanner.scanForVulnerabilities(packageJson, 'package.json');
        
        expect(report.totalFindings).toBeGreaterThan(0);
        expect(report.findings.some(f => f.category === 'dependency')).toBe(true);
      });

      it('should handle package.json with safe dependencies', async () => {
        const safePackageJson = JSON.stringify({
          name: 'safe-project',
          dependencies: {
            'safe-package': '^1.0.0',
            'another-safe-package': '^2.1.0'
          }
        }, null, 2);

        const report = await scanner.scanForVulnerabilities(safePackageJson, 'package.json');
        
        // Should have fewer dependency findings for unknown/safe packages
        const depFindings = report.findings.filter(f => f.category === 'dependency');
        expect(depFindings.length).toBeLessThanOrEqual(1);
      });

      it('should provide CVE information for dependency vulnerabilities', async () => {
        const vulnPackageJson = JSON.stringify({
          dependencies: {
            'lodash': '4.0.0'
          }
        }, null, 2);

        const report = await scanner.scanForVulnerabilities(vulnPackageJson, 'package.json');
        
        const depFinding = report.findings.find(f => f.category === 'dependency');
        if (depFinding) {
          expect(depFinding.cveIds).toBeDefined();
          expect(depFinding.remediation).toContain('version');
        }
      });
    });

    describe('Security Hotspot Identification - AC18', () => {
      it('should identify security hotspots', async () => {
        const hotspotCode = `
          const secret = "hardcoded_secret_123";
          eval(userInput);
          const template = \`Hello \${userContent}\`;
          const hash = md5(password);
        `;

        const report = await scanner.scanForVulnerabilities(hotspotCode, 'test-hotspots.js');
        
        expect(report.hotspots).toBeDefined();
        expect(report.hotspots.length).toBeGreaterThan(0);
        expect(report.summary.hotspotsCount).toBeGreaterThan(0);
      });

      it('should prioritize hotspots by confidence and severity', async () => {
        const criticalHotspotCode = `
          const apiKey = "sk-live-1234567890abcdef";
          exec("rm -rf " + userPath);
        `;

        const report = await scanner.scanForVulnerabilities(criticalHotspotCode, 'critical-hotspots.js');
        
        const highConfidenceHotspots = report.hotspots.filter(h => h.confidence === 'high');
        const criticalHotspots = report.hotspots.filter(h => h.severity === 'critical');
        
        expect(highConfidenceHotspots.length).toBeGreaterThan(0);
        expect(criticalHotspots.length).toBeGreaterThan(0);
      });

      it('should provide remediation guidance for hotspots', async () => {
        const hotspotCode = 'const password = "myPassword123";';
        const report = await scanner.scanForVulnerabilities(hotspotCode, 'test-remediation.js');
        
        expect(report.hotspots.length).toBeGreaterThan(0);
        expect(report.hotspots[0].remediation).toBeDefined();
        expect(report.hotspots[0].remediation.length).toBeGreaterThan(0);
      });
    });

    describe('CVE Database Integration - AC13', () => {
      it('should support CVE database updates', async () => {
        const cveEntry = {
          id: 'CVE-2023-TEST',
          description: 'Test CVE entry',
          severity: 'high' as SecuritySeverity,
          cvssScore: 7.5,
          publishedDate: '2023-01-01T00:00:00Z',
          lastModifiedDate: '2023-01-01T00:00:00Z',
          references: ['https://example.com/cve-test']
        };

        scanner.updateCVEDatabase([cveEntry]);
        
        const stats = scanner.getVulnerabilityStatistics();
        expect(stats.cveEntries).toBeGreaterThan(0);
      });

      it('should map findings to CVE entries when available', async () => {
        const testPattern = {
          id: 'cve-mapped-pattern',
          name: 'CVE Mapped Pattern',
          description: 'Pattern mapped to CVE',
          severity: 'high' as SecuritySeverity,
          category: 'injection' as const,
          pattern: /cveTestFunction\s*\(/i,
          cveIds: ['CVE-2023-TEST']
        };

        scanner.addVulnerabilityPattern(testPattern);

        const testCode = 'cveTestFunction(userInput);';
        const report = await scanner.scanForVulnerabilities(testCode, 'test-cve.js');
        
        const finding = report.findings.find(f => f.id.includes('cve-mapped-pattern'));
        expect(finding).toBeDefined();
        expect(finding?.cveIds).toContain('CVE-2023-TEST');
      });
    });

    describe('Performance Requirements', () => {
      it('should complete vulnerability scans within reasonable time', async () => {
        const largeCode = 'console.log("test");\n'.repeat(1000);
        
        const startTime = Date.now();
        const report = await scanner.scanForVulnerabilities(largeCode, 'large-file.js');
        const endTime = Date.now();
        
        expect(endTime - startTime).toBeLessThan(5000); // Should complete within 5 seconds
        expect(report.scanDuration).toBeDefined();
      });

      it('should include performance metadata in reports', async () => {
        const testCode = 'console.log("test");';
        const report = await scanner.scanForVulnerabilities(testCode, 'test-perf.js');
        
        expect(report.scanDuration).toBeDefined();
        expect(report.timestamp).toBeDefined();
        expect(report.metadata).toBeDefined();
        expect(report.metadata.scannerVersion).toBeDefined();
      });
    });

    describe('Error Handling', () => {
      it('should handle malformed code gracefully', async () => {
        const malformedCode = 'function test() { const x = ';
        
        expect(async () => {
          await scanner.scanForVulnerabilities(malformedCode, 'malformed.js');
        }).not.toThrow();
      });

      it('should handle empty or null input', async () => {
        const emptyReport = await scanner.scanForVulnerabilities('', 'empty.js');
        expect(emptyReport.totalFindings).toBe(0);
        expect(emptyReport.findings).toEqual([]);
      });

      it('should handle invalid dependency files gracefully', async () => {
        const invalidJson = '{ "name": "test", invalid json }';
        
        expect(async () => {
          await scanner.scanForVulnerabilities(invalidJson, 'package.json');
        }).not.toThrow();
      });
    });

    describe('Vulnerability Statistics', () => {
      it('should provide comprehensive statistics', async () => {
        const stats = scanner.getVulnerabilityStatistics();
        
        expect(stats.totalPatterns).toBeGreaterThan(0);
        expect(stats.patternsByCategory).toBeDefined();
        expect(stats.cacheSize).toBeDefined();
        expect(typeof stats.cveEntries).toBe('number');
      });

      it('should track patterns by category', async () => {
        const stats = scanner.getVulnerabilityStatistics();
        
        expect(stats.patternsByCategory.injection).toBeGreaterThan(0);
        expect(stats.patternsByCategory.authentication).toBeGreaterThan(0);
        expect(stats.patternsByCategory.cryptographic).toBeGreaterThan(0);
      });
    });

    describe('Integration Requirements', () => {
      it('should integrate with existing security architecture', async () => {
        const testCode = 'const test = "sample code";';
        const report = await scanner.scanForVulnerabilities(testCode);
        
        // Should return proper VulnerabilityReport structure
        expect(report).toBeDefined();
        expect(report.findings).toBeInstanceOf(Array);
        expect(report.hotspots).toBeInstanceOf(Array);
        expect(report.summary).toBeDefined();
      });

      it('should support integration with other security components', async () => {
        // Verify that the scanner can be used as part of larger security audit
        const testCode = 'const apiKey = "test-key-123";';
        const report = await scanner.scanForVulnerabilities(testCode, 'integration-test.js');
        
        expect(report.metadata.configLevel).toBe('comprehensive');
        expect(report.metadata.patternsUsed).toBeInstanceOf(Array);
      });
    });
  });
});