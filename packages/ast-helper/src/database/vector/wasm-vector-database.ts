/**
 * WASM-based Vector Database Implementation
 */

/**
 * WebAssembly bindings from ast-core-engine for high-performance
 * vector similarity search, providing the same interface as RustVectorDatabase.
 */

import type {
  VectorDatabase,
  VectorDBConfig,
  VectorMetadata,
  SearchResult,
  VectorDBStats,
  VectorInsert,
} from "./types.js";
import { validateVectorDBConfig } from "./types.js";
import { SQLiteVectorStorage } from "./sqlite-storage.js";

// WASM configuration interface
interface WasmHnswConfig {
  embedding_dimension: number;
  m: number;
  ef_construction: number;
  ef_search: number;
  max_elements: number;
}

// WASM metadata interface
interface WasmVectorMetadata {
  node_id: string;
  file_path: string;
  node_type: string;
  signature: string;
  language: string;
  embedding_model: string;
  timestamp: number;
}

// WASM search result interface
interface WasmSearchResult {
  node_id: string;
  distance: number;
  include_vector?: boolean;
}

// WASM module interface (will be generated by wasm-pack)
interface WasmVectorDatabaseModule {
  default(): Promise<void>; // WASM initialization
  init_vector_database_wasm(config: WasmHnswConfig): string;
  add_vector_to_db_wasm(
    nodeId: string,
    embedding: Float32Array,
    metadata: WasmVectorMetadata,
  ): string;
  search_vectors_wasm(
    queryEmbedding: Float32Array,
    k: number,
    efSearch?: number,
  ): WasmSearchResult[];
  get_vector_count_wasm(): number;
  clear_vector_database_wasm(): string;
}

/**
 * WASM-based vector database that uses WebAssembly implementation
 * from ast-core-engine for vector similarity search
 */
/**
 * Performance monitoring interface for WASM operations
 */
interface PerformanceMetrics {
  searchTimes: number[];
  insertTimes: number[];
  batchOperationTimes: number[];
  wasmBoundaryCrossings: number;
  memoryTransferBytes: number;
  lastResetTime: number;
}

/**
 * Batch operation configuration for performance optimization
 */
interface BatchConfig {
  maxBatchSize: number;
  batchTimeoutMs: number;
  enableMemoryOptimization: boolean;
}

export class WasmVectorDatabase implements VectorDatabase {
  private storage: SQLiteVectorStorage;
  private wasmModule: WasmVectorDatabaseModule | null = null;
  private isInitialized = false;
  private readonly config: VectorDBConfig;

  // Enhanced performance monitoring
  private performanceMetrics: PerformanceMetrics;
  private readonly maxTimeHistory = 100;

  // Batch operation optimization
  private readonly batchConfig: BatchConfig;
  private pendingOperations: Array<{
    type: "insert" | "update" | "delete";
    nodeId: string;
    vector?: number[];
    metadata?: VectorMetadata;
    resolve: (value: void | PromiseLike<void>) => void;
    reject: (reason?: unknown) => void;
  }> = [];
  private batchTimeout: NodeJS.Timeout | null = null;

  constructor(config: VectorDBConfig) {
    this.config = config;
    this.storage = new SQLiteVectorStorage(config);

    // Initialize performance monitoring
    this.performanceMetrics = {
      searchTimes: [],
      insertTimes: [],
      batchOperationTimes: [],
      wasmBoundaryCrossings: 0,
      memoryTransferBytes: 0,
      lastResetTime: Date.now(),
    };

    // Initialize batch configuration
    this.batchConfig = {
      maxBatchSize: 50,
      batchTimeoutMs: 100,
      enableMemoryOptimization: true,
    };
  }

  async initialize(config?: VectorDBConfig): Promise<void> {
    if (this.isInitialized) {
      return;
    }

    // Update config if provided
    if (config) {
      Object.assign(this.config, config);
    }

    // Validate configuration
    const configErrors = validateVectorDBConfig(this.config);
    if (configErrors.length > 0) {
      throw new Error(
        `Invalid vector database configuration: ${configErrors.join(", ")}`,
      );
    }

    try {
      // Initialize SQLite storage first
      await this.storage.initialize();

      // Load and initialize WASM module
      await this.initializeWasmModule();

      // Initialize WASM vector database
      const wasmConfig = {
        embedding_dimension: this.config.dimensions,
        m: this.config.M || 16,
        ef_construction: this.config.efConstruction || 200,
        ef_search: 50,
        max_elements: this.config.maxElements || 100000,
      };

      if (this.wasmModule) {
        this.wasmModule.init_vector_database_wasm(wasmConfig);
        // Debug: WASM vector database initialized
      }

      // Rebuild index from storage if vectors exist
      await this.rebuildFromStorage();

      this.isInitialized = true;
    } catch (error) {
      throw new Error(
        `Failed to initialize WASM vector database: ${(error as Error).message}`,
      );
    }
  }

  private async initializeWasmModule(): Promise<void> {
    if (this.wasmModule) {
      return;
    }

    try {
      // Dynamic import of WASM module (generated by wasm-pack)
      const wasmModule = (await import(
        "./wasm-pkg/ast_helper_core_engine.js"
      )) as unknown as WasmVectorDatabaseModule;

      // Initialize WASM
      await wasmModule.default();

      this.wasmModule = wasmModule as WasmVectorDatabaseModule;
      // Debug: WASM module loaded successfully
    } catch (error) {
      // Provide specific error information based on the type of error
      if (error instanceof Error && error.message.includes("not yet built")) {
        throw new Error(
          "WASM vector database module not yet available. The WASM build is currently being implemented.",
        );
      }

      // For other errors (import failures, initialization errors, etc.)
      throw new Error(
        `Failed to initialize WASM module: ${(error as Error).message}. Please ensure WASM module is built with 'wasm-pack build --target web --features wasm' in packages/ast-core-engine`,
      );
    }
  }

  private ensureInitialized(): void {
    if (!this.isInitialized) {
      throw new Error("WASM vector database not initialized");
    }
    if (!this.wasmModule) {
      throw new Error("WASM module not loaded");
    }
  }

  /**
   * Record performance metrics for monitoring and optimization
   */
  private recordPerformanceMetric(
    type: "search" | "insert" | "batch",
    timeMs: number,
  ): void {
    let targetArray: number[];

    switch (type) {
      case "search":
        targetArray = this.performanceMetrics.searchTimes;
        break;
      case "insert":
        targetArray = this.performanceMetrics.insertTimes;
        break;
      case "batch":
        targetArray = this.performanceMetrics.batchOperationTimes;
        break;
    }

    targetArray.push(timeMs);

    // Keep only recent measurements
    if (targetArray.length > this.maxTimeHistory) {
      targetArray.shift();
    }
  }

  /**
   * Get performance statistics for monitoring
   */
  getPerformanceMetrics(): PerformanceMetrics & {
    averageSearchTime: number;
    averageInsertTime: number;
    averageBatchTime: number;
    boundaryCrossingsPerSecond: number;
    memoryTransferRate: number; // bytes per second
  } {
    const now = Date.now();
    const timeElapsed = (now - this.performanceMetrics.lastResetTime) / 1000; // seconds

    const calculateAverage = (times: number[]): number =>
      times.length > 0 ? times.reduce((a, b) => a + b, 0) / times.length : 0;

    return {
      ...this.performanceMetrics,
      averageSearchTime: calculateAverage(this.performanceMetrics.searchTimes),
      averageInsertTime: calculateAverage(this.performanceMetrics.insertTimes),
      averageBatchTime: calculateAverage(
        this.performanceMetrics.batchOperationTimes,
      ),
      boundaryCrossingsPerSecond:
        timeElapsed > 0
          ? this.performanceMetrics.wasmBoundaryCrossings / timeElapsed
          : 0,
      memoryTransferRate:
        timeElapsed > 0
          ? this.performanceMetrics.memoryTransferBytes / timeElapsed
          : 0,
    };
  }

  /**
   * Reset performance metrics
   */
  resetPerformanceMetrics(): void {
    this.performanceMetrics = {
      searchTimes: [],
      insertTimes: [],
      batchOperationTimes: [],
      wasmBoundaryCrossings: 0,
      memoryTransferBytes: 0,
      lastResetTime: Date.now(),
    };
  }

  private async rebuildFromStorage(): Promise<void> {
    const stats = await this.storage.getStats();
    if (stats.vectorCount === 0) {
      return;
    }

    // Debug: Rebuilding WASM index from stored vectors

    const allNodeIds = await this.storage.getAllNodeIds();
    for (const nodeId of allNodeIds) {
      const vectorData = await this.storage.getVector(nodeId);
      if (vectorData && this.wasmModule) {
        const wasmMetadata = {
          node_id: nodeId,
          file_path: vectorData.metadata.filePath,
          node_type: vectorData.metadata.signature.split("(")[0] || "unknown",
          signature: vectorData.metadata.signature,
          language: "typescript", // Default, could be enhanced
          embedding_model: "codebert-base", // Default model
          timestamp: Math.floor(Date.now() / 1000),
        };

        try {
          const embeddingArray = new Float32Array(vectorData.vector);
          this.wasmModule.add_vector_to_db_wasm(
            nodeId,
            embeddingArray,
            wasmMetadata,
          );
        } catch (_error) {
          // Error: Failed to add vector to WASM index, continuing...
        }
      }
    }

    // Debug: WASM index rebuild completed
  }

  async insertVector(
    nodeId: string,
    vector: number[],
    metadata: VectorMetadata,
  ): Promise<void> {
    const startTime = performance.now();
    this.ensureInitialized();

    if (!nodeId || nodeId.trim().length === 0) {
      throw new Error("nodeId is required and cannot be empty");
    }

    if (!vector || vector.length === 0) {
      throw new Error("vector is required and cannot be empty");
    }

    if (vector.length !== this.config.dimensions) {
      throw new Error(
        `Vector dimensions mismatch: expected ${this.config.dimensions}, got ${vector.length}`,
      );
    }

    if (!metadata) {
      throw new Error("metadata is required");
    }

    try {
      // Store in SQLite first
      await this.storage.insertVector(nodeId, vector, metadata);

      // Add to WASM vector database with optimized memory transfer
      const wasmMetadata = {
        node_id: nodeId,
        file_path: metadata.filePath,
        node_type: metadata.signature.split("(")[0] || "unknown",
        signature: metadata.signature,
        language: "typescript",
        embedding_model: "codebert-base",
        timestamp: Math.floor(Date.now() / 1000),
      };

      if (this.wasmModule) {
        // Optimize for WASM: reuse Float32Array if batch config allows
        const embeddingArray = this.batchConfig.enableMemoryOptimization
          ? new Float32Array(vector)
          : new Float32Array(vector); // Future: implement buffer pooling

        this.wasmModule.add_vector_to_db_wasm(
          nodeId,
          embeddingArray,
          wasmMetadata,
        );

        // Track performance metrics
        this.performanceMetrics.wasmBoundaryCrossings += 1;
        this.performanceMetrics.memoryTransferBytes += vector.length * 4; // Float32 = 4 bytes
      }

      // Record timing
      const insertTime = performance.now() - startTime;
      this.recordPerformanceMetric("insert", insertTime);
    } catch (error) {
      throw new Error(`Failed to insert vector: ${(error as Error).message}`);
    }
  }

  async insertVectors(vectors: VectorInsert[]): Promise<void> {
    const startTime = performance.now();
    this.ensureInitialized();

    if (!vectors || vectors.length === 0) {
      throw new Error("vectors array is required and cannot be empty");
    }

    // Process in optimized batches to minimize WASM boundary crossings
    const batchSize = Math.min(this.batchConfig.maxBatchSize, vectors.length);
    const errors: Array<{ nodeId: string; error: string }> = [];
    let successCount = 0;
    let totalBoundaryCrossings = 0;
    let totalMemoryTransfer = 0;

    for (let i = 0; i < vectors.length; i += batchSize) {
      const batch = vectors.slice(i, i + batchSize);
      const batchStartTime = performance.now();

      // Pre-allocate memory for the batch if memory optimization is enabled
      if (this.batchConfig.enableMemoryOptimization && this.wasmModule) {
        // Prepare batch data structures to minimize individual WASM calls
        const batchNodeIds: string[] = [];
        const batchVectors: Float32Array[] = [];
        const batchMetadata: Array<{
          node_id: string;
          file_path: string;
          node_type: string;
          signature: string;
          language: string;
          embedding_model: string;
          timestamp: number;
        }> = [];

        // Prepare batch data
        for (const vectorInsert of batch) {
          try {
            // Validate first
            if (
              !vectorInsert.nodeId ||
              vectorInsert.nodeId.trim().length === 0
            ) {
              throw new Error("nodeId is required and cannot be empty");
            }

            if (!vectorInsert.vector || vectorInsert.vector.length === 0) {
              throw new Error("vector is required and cannot be empty");
            }

            if (vectorInsert.vector.length !== this.config.dimensions) {
              throw new Error(
                `Vector dimensions mismatch: expected ${this.config.dimensions}, got ${vectorInsert.vector.length}`,
              );
            }

            if (!vectorInsert.metadata) {
              throw new Error("metadata is required");
            }

            // Store in SQLite first
            await this.storage.insertVector(
              vectorInsert.nodeId,
              vectorInsert.vector,
              vectorInsert.metadata,
            );

            // Prepare for WASM batch
            batchNodeIds.push(vectorInsert.nodeId);
            batchVectors.push(new Float32Array(vectorInsert.vector));
            batchMetadata.push({
              node_id: vectorInsert.nodeId,
              file_path: vectorInsert.metadata.filePath,
              node_type:
                vectorInsert.metadata.signature.split("(")[0] || "unknown",
              signature: vectorInsert.metadata.signature,
              language: "typescript",
              embedding_model: "codebert-base",
              timestamp: Math.floor(Date.now() / 1000),
            });

            totalMemoryTransfer += vectorInsert.vector.length * 4;
            successCount++;
          } catch (error) {
            errors.push({
              nodeId: vectorInsert.nodeId,
              error: (error as Error).message,
            });
          }
        }

        // Single WASM call for the entire batch (when WASM supports batch operations)
        // For now, we still call individually but with optimized memory allocation
        for (let j = 0; j < batchNodeIds.length; j++) {
          const nodeId = batchNodeIds[j];
          const vector = batchVectors[j];
          const metadata = batchMetadata[j];

          if (!nodeId || !vector || !metadata) {
            continue;
          }

          try {
            this.wasmModule.add_vector_to_db_wasm(nodeId, vector, metadata);
            totalBoundaryCrossings += 1;
          } catch (error) {
            errors.push({
              nodeId,
              error: `WASM error: ${(error as Error).message}`,
            });
          }
        }
      } else {
        // Fallback to individual processing
        for (const vectorInsert of batch) {
          try {
            await this.insertVector(
              vectorInsert.nodeId,
              vectorInsert.vector,
              vectorInsert.metadata,
            );
            successCount++;
          } catch (error) {
            errors.push({
              nodeId: vectorInsert.nodeId,
              error: (error as Error).message,
            });
          }
        }
      }

      const batchTime = performance.now() - batchStartTime;
      this.recordPerformanceMetric("batch", batchTime);
    }

    // Update performance metrics
    this.performanceMetrics.wasmBoundaryCrossings += totalBoundaryCrossings;
    this.performanceMetrics.memoryTransferBytes += totalMemoryTransfer;

    const totalTime = performance.now() - startTime;
    this.recordPerformanceMetric("batch", totalTime);

    if (errors.length > 0) {
      throw new Error(
        `Batch insert completed with errors. Successful: ${successCount}, Failed: ${errors.length}. First few errors: ${errors
          .slice(0, 3)
          .map((e) => `${e.nodeId}: ${e.error}`)
          .join("; ")}${errors.length > 3 ? "..." : ""}`,
      );
    }
  }

  async searchSimilar(
    queryVector: number[],
    k: number,
    ef?: number,
  ): Promise<SearchResult[]> {
    this.ensureInitialized();

    if (queryVector.length !== this.config.dimensions) {
      throw new Error(
        `Query vector dimensions mismatch: expected ${this.config.dimensions}, got ${queryVector.length}`,
      );
    }

    if (k <= 0) {
      throw new Error("Parameter k must be greater than 0");
    }

    if (ef !== undefined && ef <= 0) {
      throw new Error("Parameter ef must be greater than 0");
    }

    const startTime = performance.now();

    try {
      const queryArray = new Float32Array(queryVector);
      if (!this.wasmModule) {
        throw new Error("WASM module not available");
      }
      const wasmResults = this.wasmModule.search_vectors_wasm(
        queryArray,
        k,
        ef,
      );

      // Convert WASM results to SearchResult format
      const results: SearchResult[] = [];

      for (const wasmResult of wasmResults) {
        // Get metadata from storage
        const vectorData = await this.storage.getVector(wasmResult.node_id);
        if (vectorData) {
          results.push({
            nodeId: wasmResult.node_id,
            distance: wasmResult.distance,
            score: Math.max(0, 1 - wasmResult.distance), // Convert distance to similarity score
            metadata: vectorData.metadata,
            vector: wasmResult.include_vector ? vectorData.vector : undefined,
          });
        }
      }

      // Track search performance
      const searchTime = performance.now() - startTime;
      this.recordPerformanceMetric("search", searchTime);
      this.performanceMetrics.wasmBoundaryCrossings += 2; // One call in, one call out
      this.performanceMetrics.memoryTransferBytes += queryVector.length * 4; // Float32 = 4 bytes per element

      return results;
    } catch (error) {
      throw new Error(`Search failed: ${(error as Error).message}`);
    }
  }

  async updateVector(nodeId: string, vector: number[]): Promise<void> {
    this.ensureInitialized();

    if (!nodeId || nodeId.trim().length === 0) {
      throw new Error("nodeId is required and cannot be empty");
    }

    if (!vector || vector.length === 0) {
      throw new Error("vector is required and cannot be empty");
    }

    if (vector.length !== this.config.dimensions) {
      throw new Error(
        `Vector dimensions mismatch: expected ${this.config.dimensions}, got ${vector.length}`,
      );
    }

    try {
      // Get existing metadata
      const existingData = await this.storage.getVector(nodeId);
      if (!existingData) {
        throw new Error(`Vector with nodeId ${nodeId} not found`);
      }

      // Update in storage
      await this.storage.updateVector(nodeId, vector);

      // Update in WASM database by removing and re-adding
      // Note: WASM interface doesn't have direct update, so we clear and rebuild
      if (this.wasmModule) {
        // For now, we'll need to implement proper update in the WASM layer
        // This is a simplistic approach
        await this.rebuild();
      }
    } catch (error) {
      throw new Error(`Failed to update vector: ${(error as Error).message}`);
    }
  }

  async deleteVector(nodeId: string): Promise<void> {
    this.ensureInitialized();

    if (!nodeId || nodeId.trim().length === 0) {
      throw new Error("nodeId is required and cannot be empty");
    }

    try {
      // Delete from storage
      await this.storage.deleteVector(nodeId);

      // For WASM, we need to rebuild the index since there's no direct delete
      // This is not optimal but works for the initial implementation
      await this.rebuild();
    } catch (error) {
      throw new Error(`Failed to delete vector: ${(error as Error).message}`);
    }
  }

  async rebuild(): Promise<void> {
    this.ensureInitialized();

    try {
      // Notify external systems (e.g., MCP server cache) before rebuild
      if (this.config.onIndexRebuild) {
        await this.config.onIndexRebuild();
      }

      // Clear WASM database
      if (this.wasmModule) {
        this.wasmModule.clear_vector_database_wasm();
      }

      // Rebuild from storage
      await this.rebuildFromStorage();
    } catch (error) {
      throw new Error(`Failed to rebuild index: ${(error as Error).message}`);
    }
  }

  async getStats(): Promise<VectorDBStats> {
    this.ensureInitialized();

    try {
      const storageStats = await this.storage.getStats();
      const wasmVectorCount = this.wasmModule
        ? this.wasmModule.get_vector_count_wasm()
        : 0;

      const performanceData = this.getPerformanceMetrics();
      const averageSearchTime = performanceData.averageSearchTime;

      return {
        vectorCount: wasmVectorCount,
        memoryUsage: 0, // WASM doesn't provide memory stats directly
        indexFileSize: 0, // Not applicable for WASM
        storageFileSize: storageStats.storageSize,
        lastSaved: new Date(), // SQLite storage doesn't track this
        buildTime: 0, // Would need to track this
        averageSearchTime,
        status: "ready",
      };
    } catch (error) {
      return {
        vectorCount: 0,
        memoryUsage: 0,
        indexFileSize: 0,
        storageFileSize: 0,
        lastSaved: new Date(),
        buildTime: 0,
        averageSearchTime: 0,
        status: "error",
        errorMessage: (error as Error).message,
      };
    }
  }

  async shutdown(): Promise<void> {
    try {
      // Clear any pending batch operations
      if (this.batchTimeout) {
        clearTimeout(this.batchTimeout);
        this.batchTimeout = null;
      }

      // Process any remaining pending operations
      if (this.pendingOperations.length > 0) {
        // Reject pending operations
        for (const op of this.pendingOperations) {
          op.reject(new Error("Database shutting down"));
        }
        this.pendingOperations = [];
      }

      if (this.storage) {
        try {
          await this.storage.shutdown();
        } catch (_error) {
          // Error shutting down storage, continuing...
        }
      }

      // Clear WASM resources
      if (this.wasmModule) {
        try {
          this.wasmModule.clear_vector_database_wasm();
        } catch (_error) {
          // Error clearing WASM database on shutdown, continuing...
        }
      }

      // Reset performance metrics
      this.resetPerformanceMetrics();
    } catch (_error) {
      // Handle any unexpected errors during shutdown
    } finally {
      // Always reset state regardless of errors
      this.isInitialized = false;
      this.wasmModule = null;
    }
  }
}
