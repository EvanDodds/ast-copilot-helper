/**
 * WASM-based Vector Database Implementation
 *
 * Uses WebAssembly bindings from ast-core-engine for high-performance
 * vector similarity search, providing the same interface as RustVectorDatabase.
 */

import type {
  VectorDatabase,
  VectorDBConfig,
  VectorMetadata,
  SearchResult,
  VectorDBStats,
  VectorInsert,
} from "./types.js";
import { SQLiteVectorStorage } from "./sqlite-storage.js";

// WASM configuration interface
interface WasmHnswConfig {
  embedding_dimension: number;
  m: number;
  ef_construction: number;
  ef_search: number;
  max_elements: number;
}

// WASM metadata interface
interface WasmVectorMetadata {
  node_id: string;
  file_path: string;
  node_type: string;
  signature: string;
  language: string;
  embedding_model: string;
  timestamp: number;
}

// WASM search result interface
interface WasmSearchResult {
  node_id: string;
  distance: number;
  include_vector?: boolean;
}

// WASM module interface (will be generated by wasm-pack)
interface WasmVectorDatabaseModule {
  default(): Promise<void>; // WASM initialization
  init_vector_database_wasm(config: WasmHnswConfig): string;
  add_vector_to_db_wasm(
    nodeId: string,
    embedding: Float32Array,
    metadata: WasmVectorMetadata,
  ): string;
  search_vectors_wasm(
    queryEmbedding: Float32Array,
    k: number,
    efSearch?: number,
  ): WasmSearchResult[];
  get_vector_count_wasm(): number;
  clear_vector_database_wasm(): string;
}

/**
 * WASM-based vector database that uses WebAssembly implementation
 * from ast-core-engine for vector similarity search
 */
export class WasmVectorDatabase implements VectorDatabase {
  private storage: SQLiteVectorStorage;
  private wasmModule: WasmVectorDatabaseModule | null = null;
  private isInitialized = false;
  private readonly config: VectorDBConfig;
  private searchTimes: number[] = [];
  private readonly maxSearchTimeHistory = 100;

  constructor(config: VectorDBConfig) {
    this.config = config;
    this.storage = new SQLiteVectorStorage(config);
  }

  async initialize(_config?: VectorDBConfig): Promise<void> {
    if (this.isInitialized) {
      return;
    }

    try {
      // Initialize SQLite storage first
      await this.storage.initialize();

      // Load and initialize WASM module
      await this.initializeWasmModule();

      // Initialize WASM vector database
      const wasmConfig = {
        embedding_dimension: this.config.dimensions,
        m: this.config.M || 16,
        ef_construction: this.config.efConstruction || 200,
        ef_search: 50,
        max_elements: this.config.maxElements || 100000,
      };

      if (this.wasmModule) {
        this.wasmModule.init_vector_database_wasm(wasmConfig);
        // Debug: WASM vector database initialized
      }

      // Rebuild index from storage if vectors exist
      await this.rebuildFromStorage();

      this.isInitialized = true;
    } catch (error) {
      throw new Error(
        `Failed to initialize WASM vector database: ${(error as Error).message}`,
      );
    }
  }

  private async initializeWasmModule(): Promise<void> {
    if (this.wasmModule) {
      return;
    }

    try {
      // Dynamic import of WASM module (will be generated by wasm-pack)
      // TODO: Enable when WASM build is ready
      // const wasmModule = await import("@ast-helper/core-engine/pkg/ast_core_engine.js");

      // Temporary: throw error until WASM module is available
      throw new Error("WASM module not yet built");

      const wasmModule = null as unknown as WasmVectorDatabaseModule;

      // Initialize WASM
      await wasmModule.default();

      this.wasmModule = wasmModule as WasmVectorDatabaseModule;
      // Debug: WASM module loaded successfully
    } catch (_error) {
      // Fallback error until WASM module is built
      throw new Error(
        "WASM module not available. Please run 'wasm-pack build --target web --features wasm' in packages/ast-core-engine",
      );
    }
  }

  private ensureInitialized(): void {
    if (!this.isInitialized) {
      throw new Error("WASM vector database not initialized");
    }
    if (!this.wasmModule) {
      throw new Error("WASM module not loaded");
    }
  }

  private async rebuildFromStorage(): Promise<void> {
    const stats = await this.storage.getStats();
    if (stats.vectorCount === 0) {
      return;
    }

    // Debug: Rebuilding WASM index from stored vectors

    const allNodeIds = await this.storage.getAllNodeIds();
    for (const nodeId of allNodeIds) {
      const vectorData = await this.storage.getVector(nodeId);
      if (vectorData && this.wasmModule) {
        const wasmMetadata = {
          node_id: nodeId,
          file_path: vectorData.metadata.filePath,
          node_type: vectorData.metadata.signature.split("(")[0] || "unknown",
          signature: vectorData.metadata.signature,
          language: "typescript", // Default, could be enhanced
          embedding_model: "codebert-base", // Default model
          timestamp: Math.floor(Date.now() / 1000),
        };

        try {
          const embeddingArray = new Float32Array(vectorData.vector);
          this.wasmModule.add_vector_to_db_wasm(
            nodeId,
            embeddingArray,
            wasmMetadata,
          );
        } catch (_error) {
          // Error: Failed to add vector to WASM index, continuing...
        }
      }
    }

    // Debug: WASM index rebuild completed
  }

  async insertVector(
    nodeId: string,
    vector: number[],
    metadata: VectorMetadata,
  ): Promise<void> {
    this.ensureInitialized();

    if (vector.length !== this.config.dimensions) {
      throw new Error(
        `Vector dimensions mismatch: expected ${this.config.dimensions}, got ${vector.length}`,
      );
    }

    try {
      // Store in SQLite first
      await this.storage.insertVector(nodeId, vector, metadata);

      // Add to WASM vector database
      const wasmMetadata = {
        node_id: nodeId,
        file_path: metadata.filePath,
        node_type: metadata.signature.split("(")[0] || "unknown",
        signature: metadata.signature,
        language: "typescript",
        embedding_model: "codebert-base",
        timestamp: Math.floor(Date.now() / 1000),
      };

      const embeddingArray = new Float32Array(vector);
      if (this.wasmModule) {
        this.wasmModule.add_vector_to_db_wasm(
          nodeId,
          embeddingArray,
          wasmMetadata,
        );
      }
    } catch (error) {
      throw new Error(`Failed to insert vector: ${(error as Error).message}`);
    }
  }

  async insertVectors(vectors: VectorInsert[]): Promise<void> {
    this.ensureInitialized();

    // Batch insert - process each vector
    for (const vectorInsert of vectors) {
      await this.insertVector(
        vectorInsert.nodeId,
        vectorInsert.vector,
        vectorInsert.metadata,
      );
    }
  }

  async searchSimilar(
    queryVector: number[],
    k = 10,
    ef?: number,
  ): Promise<SearchResult[]> {
    this.ensureInitialized();

    if (queryVector.length !== this.config.dimensions) {
      throw new Error(
        `Query vector dimensions mismatch: expected ${this.config.dimensions}, got ${queryVector.length}`,
      );
    }

    const startTime = performance.now();

    try {
      const queryArray = new Float32Array(queryVector);
      if (!this.wasmModule) {
        throw new Error("WASM module not available");
      }
      const wasmResults = this.wasmModule.search_vectors_wasm(
        queryArray,
        k,
        ef,
      );

      // Convert WASM results to SearchResult format
      const results: SearchResult[] = [];

      for (const wasmResult of wasmResults) {
        // Get metadata from storage
        const vectorData = await this.storage.getVector(wasmResult.node_id);
        if (vectorData) {
          results.push({
            nodeId: wasmResult.node_id,
            distance: wasmResult.distance,
            score: Math.max(0, 1 - wasmResult.distance), // Convert distance to similarity score
            metadata: vectorData.metadata,
            vector: wasmResult.include_vector ? vectorData.vector : undefined,
          });
        }
      }

      // Track search performance
      const searchTime = performance.now() - startTime;
      this.searchTimes.push(searchTime);
      if (this.searchTimes.length > this.maxSearchTimeHistory) {
        this.searchTimes.shift();
      }

      return results;
    } catch (error) {
      throw new Error(`Search failed: ${(error as Error).message}`);
    }
  }

  async updateVector(nodeId: string, vector: number[]): Promise<void> {
    this.ensureInitialized();

    if (vector.length !== this.config.dimensions) {
      throw new Error(
        `Vector dimensions mismatch: expected ${this.config.dimensions}, got ${vector.length}`,
      );
    }

    try {
      // Get existing metadata
      const existingData = await this.storage.getVector(nodeId);
      if (!existingData) {
        throw new Error(`Vector with nodeId ${nodeId} not found`);
      }

      // Update in storage
      await this.storage.updateVector(nodeId, vector);

      // Update in WASM database by removing and re-adding
      // Note: WASM interface doesn't have direct update, so we clear and rebuild
      if (this.wasmModule) {
        // For now, we'll need to implement proper update in the WASM layer
        // This is a simplistic approach
        await this.rebuild();
      }
    } catch (error) {
      throw new Error(`Failed to update vector: ${(error as Error).message}`);
    }
  }

  async deleteVector(nodeId: string): Promise<void> {
    this.ensureInitialized();

    try {
      // Delete from storage
      await this.storage.deleteVector(nodeId);

      // For WASM, we need to rebuild the index since there's no direct delete
      // This is not optimal but works for the initial implementation
      await this.rebuild();
    } catch (error) {
      throw new Error(`Failed to delete vector: ${(error as Error).message}`);
    }
  }

  async rebuild(): Promise<void> {
    this.ensureInitialized();

    try {
      // Clear WASM database
      if (this.wasmModule) {
        this.wasmModule.clear_vector_database_wasm();
      }

      // Rebuild from storage
      await this.rebuildFromStorage();
    } catch (error) {
      throw new Error(`Failed to rebuild index: ${(error as Error).message}`);
    }
  }

  async getStats(): Promise<VectorDBStats> {
    this.ensureInitialized();

    try {
      const storageStats = await this.storage.getStats();
      const wasmVectorCount = this.wasmModule
        ? this.wasmModule.get_vector_count_wasm()
        : 0;

      const averageSearchTime =
        this.searchTimes.length > 0
          ? this.searchTimes.reduce((a, b) => a + b, 0) /
            this.searchTimes.length
          : 0;

      return {
        vectorCount: wasmVectorCount,
        memoryUsage: 0, // WASM doesn't provide memory stats directly
        indexFileSize: 0, // Not applicable for WASM
        storageFileSize: storageStats.storageSize,
        lastSaved: new Date(), // SQLite storage doesn't track this
        buildTime: 0, // Would need to track this
        averageSearchTime,
        status: "ready",
      };
    } catch (error) {
      return {
        vectorCount: 0,
        memoryUsage: 0,
        indexFileSize: 0,
        storageFileSize: 0,
        lastSaved: new Date(),
        buildTime: 0,
        averageSearchTime: 0,
        status: "error",
        errorMessage: (error as Error).message,
      };
    }
  }

  async shutdown(): Promise<void> {
    if (this.storage) {
      await this.storage.shutdown();
    }

    // Clear WASM resources
    if (this.wasmModule) {
      try {
        this.wasmModule.clear_vector_database_wasm();
      } catch (_error) {
        // Error clearing WASM database on shutdown, continuing...
      }
    }

    this.isInitialized = false;
    this.wasmModule = null;
  }
}
