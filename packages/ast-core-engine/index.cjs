/* tslint:disable */
/* eslint-disable */

/* auto-generated by NAPI-RS */

const { existsSync, readFileSync } = require('fs')
const { join } = require('path')

const { platform, arch } = process

let nativeBinding = null
let localFileExisted = false
let loadError = null

function isMusl() {
  // For Node 10 and below, we can try to detect musl by looking at the ldd command
  if (process.platform !== 'linux') {
    return false
  }
  
  // Try to detect musl by checking if we can run ldd and if it mentions musl
  try {
    const { execSync } = require('child_process')
    const lddOutput = execSync('ldd --version 2>&1 || true', { encoding: 'utf8' })
    return lddOutput.includes('musl')
  } catch {
    // Fallback: check if /etc/alpine-release exists (Alpine Linux uses musl)
    try {
      return existsSync('/etc/alpine-release')
    } catch {
      return false
    }
  }
}

// Since we're using a custom binding approach with local .node files,
// we skip platform-specific package resolution and go directly to local files

// Try to find a local .node file
const localNodeFiles = [
  `ast-core-engine.${platform}-${arch}${isMusl() ? '-musl' : arch === 'x64' && platform === 'linux' ? '-gnu' : ''}.node`,
  'ast-core-engine.linux-x64-gnu.node',
  'ast-core-engine.node'
]

for (const nodeFile of localNodeFiles) {
  const localPath = join(__dirname, nodeFile)
  if (existsSync(localPath)) {
    try {
      nativeBinding = require(localPath)
      localFileExisted = true
      console.log(`Loaded local native binding: ${nodeFile}`)
      break
    } catch (error) {
      console.warn(`Failed to load ${nodeFile}:`, error.message)
    }
  }
}

if (!nativeBinding) {
  // For CI/development environments where .node files don't exist yet,
  // we create a stub that will fail gracefully at runtime but allow TypeScript compilation
  console.warn('⚠️  No native binding found - creating runtime stub for TypeScript compilation')
  console.warn('   This is normal in CI environments. The module will fail at runtime until Rust binaries are built.')
  console.warn(`   Platform: ${platform}, Architecture: ${arch}`)
  if (platform === 'linux') {
    console.warn(`   Musl detected: ${isMusl()}`)
  }
  console.warn('   To build native binaries: cargo build --release')
  
  // Create a stub that provides the correct interface but throws at runtime
  nativeBinding = {
    AstCoreEngineApi: class AstCoreEngineApi {
      constructor() { throw new Error('Native binding not available - run cargo build --release') }
      initialize() { throw new Error('Native binding not available - run cargo build --release') }
      processBatch() { throw new Error('Native binding not available - run cargo build --release') }
      searchSimilar() { throw new Error('Native binding not available - run cargo build --release') }
    },
    createDefaultEngine: () => { throw new Error('Native binding not available - run cargo build --release') },
    initVectorDatabase: () => { throw new Error('Native binding not available - run cargo build --release') },
    addVectorToDb: () => { throw new Error('Native binding not available - run cargo build --release') },
    searchVectors: () => { throw new Error('Native binding not available - run cargo build --release') },
    getVectorCount: () => { throw new Error('Native binding not available - run cargo build --release') },
    clearVectorDatabase: () => { throw new Error('Native binding not available - run cargo build --release') }
  }
}

// Export all the native functions and classes
const {
  AstCoreEngineApi,
  createDefaultEngine,
  initVectorDatabase,
  addVectorToDb,
  searchVectors,
  getVectorCount,
  clearVectorDatabase
} = nativeBinding

module.exports = {
  AstCoreEngineApi,
  createDefaultEngine,
  initVectorDatabase,
  addVectorToDb,
  searchVectors,
  getVectorCount,
  clearVectorDatabase
}
